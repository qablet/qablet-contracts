{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What is Qablet?","text":"<p>A Qablet timetable defines a financial product using a sequence of payments, choices and conditions. A valuation model implemented with a Qablet parser can value any contract, as long as the contract can be described using a Qablet Timetable such as this one -</p> <pre><code>      time op  quantity unit track\n03/31/2024  &gt;       0.0  USD    #1\n03/31/2024  +    2900.0  USD    #1\n03/31/2024  +      -1.0  SPX    #1\n</code></pre>"},{"location":"#overview-of-documentation","title":"Overview of Documentation","text":"<ul> <li> <p>The SPECIFICATIONS section describes the elements of the language. Start with the timetable.</p> </li> <li> <p>The CONTRACTS section documents the qablet-contracts package which contains qablet timetables for many common financial contracts such as Bonds, Options, Swaps, and Swaptions.</p> </li> </ul> <p>If you are new to Qablet, </p> <ul> <li>Start with a simple end to end example</li> <li>Then follow the Qablet Learning Path which is a set of Jupyter notebooks to walk you through simple to advanced uses of Qablet</li> <li>Qablet Demo is an interactive experience.</li> </ul>"},{"location":"examples/bond_fixed/","title":"Fixed Bond","text":"<p>This module contains examples of fixed rate bonds.</p>"},{"location":"examples/bond_fixed/#qablet_contracts.bnd.fixed.FixedCashFlows","title":"<code>FixedCashFlows</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Contract</code></p> <p>A set of Fixed Cashflows in a single currency. This example also shows how to create a timetable from arrays instead of a list of dictionaries, which is more efficient.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of cashflows.</p> required <code>times</code> <p>a list or ndarray of cashflows times.</p> required <code>amounts</code> <code>List[float]</code> <p>a list ndarray of cashflows amounts.</p> required <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; times = [datetime(2023, 12, 31), datetime(2024, 6, 30), datetime(2024, 12, 31)]\n&gt;&gt;&gt; amounts = [0.05, 0.05, 1.05]\n&gt;&gt;&gt; FixedCashFlows(\"USD\", times, amounts).print_events()\n      time op  quantity unit track\n12/31/2023  +      0.05  USD\n06/30/2024  +      0.05  USD\n12/31/2024  +      1.05  USD\n</code></pre> Source code in <code>qablet_contracts\\bnd\\fixed.py</code> <pre><code>@dataclass\nclass FixedCashFlows(Contract):\n    \"\"\"A set of **Fixed Cashflows** in a single currency. This example also shows how to create a timetable from arrays\n    instead of a list of dictionaries, which is more efficient.\n\n    Args:\n        ccy: the currency of cashflows.\n        times: a list or ndarray of cashflows times.\n        amounts: a list ndarray of cashflows amounts.\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; times = [datetime(2023, 12, 31), datetime(2024, 6, 30), datetime(2024, 12, 31)]\n        &gt;&gt;&gt; amounts = [0.05, 0.05, 1.05]\n        &gt;&gt;&gt; FixedCashFlows(\"USD\", times, amounts).print_events()\n              time op  quantity unit track\n        12/31/2023  +      0.05  USD\n        06/30/2024  +      0.05  USD\n        12/31/2024  +      1.05  USD\n    \"\"\"\n\n    ccy: str\n    dates: List[datetime]\n    amounts: List[float]\n    track: str = \"\"\n\n    def timetable(self):\n        return timetable_from_cf(\n            self.ccy, self.dates, self.amounts, self.track\n        )\n</code></pre>"},{"location":"examples/bond_fixed/#qablet_contracts.bnd.fixed.FixedBond","title":"<code>FixedBond</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Contract</code></p> <p>A Fixed Rate Bond pays a fixed rate at regular intervals, and the principal at maturity.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of cashflows.</p> required <code>coupon</code> <code>float</code> <p>the coupon rate per year.</p> required <code>maturity</code> <code>datetime</code> <p>the maturity of the bond.</p> required <code>freq</code> <code>str</code> <p>the number of coupon payments per year.</p> <code>'2BQE'</code> <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; FixedBond(\"USD\", 0.05, datetime(2023, 12, 31), datetime(2025, 12, 31), \"2QE\").print_events()\n      time op  quantity unit track\n06/30/2024  +     0.025  USD\n12/31/2024  +     0.025  USD\n06/30/2025  +     0.025  USD\n12/31/2025  +     1.025  USD\n</code></pre> Source code in <code>qablet_contracts\\bnd\\fixed.py</code> <pre><code>@dataclass\nclass FixedBond(Contract):\n    \"\"\"A **Fixed Rate Bond** pays a fixed rate at regular intervals, and the principal at maturity.\n\n    Args:\n        ccy: the currency of cashflows.\n        coupon: the coupon rate per year.\n        maturity: the maturity of the bond.\n        freq: the number of coupon payments per year.\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; FixedBond(\"USD\", 0.05, datetime(2023, 12, 31), datetime(2025, 12, 31), \"2QE\").print_events()\n              time op  quantity unit track\n        06/30/2024  +     0.025  USD\n        12/31/2024  +     0.025  USD\n        06/30/2025  +     0.025  USD\n        12/31/2025  +     1.025  USD\n    \"\"\"\n\n    ccy: str\n    coupon: float\n    accrual_start: datetime\n    maturity: datetime\n    freq: str = \"2BQE\"\n    track: str = \"\"\n\n    def timetable(self):\n        # Coupon period dates including the start of first period, and end of last period.\n        cpn_dates = pd.bdate_range(\n            self.accrual_start,\n            self.maturity,\n            freq=self.freq,\n            inclusive=\"both\",\n        )\n\n        amounts = [\n            dcf(end, start) * self.coupon\n            for start, end in zip(cpn_dates[:-1], cpn_dates[1:])\n        ]\n\n        amounts[-1] += 1  # The last payment includes the principal\n        return timetable_from_cf(self.ccy, cpn_dates[1:], amounts, self.track)\n</code></pre>"},{"location":"examples/bond_zero/","title":"Zero Bond","text":"<p>This module contains examples of zero coupon bond and related contracts.</p>"},{"location":"examples/bond_zero/#qablet_contracts.bnd.zero.Bond","title":"<code>Bond</code>  <code>dataclass</code>","text":"<p>               Bases: <code>EventsMixin</code></p> <p>A zero coupon bond pays a single fixed payment at a future time.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the bond.</p> required <code>maturity</code> <code>datetime</code> <p>the maturity of the bond.</p> required <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Bond(\"USD\", datetime(2025, 3, 31)).print_events()\n      time op  quantity unit track\n03/31/2025  +       1.0  USD\n</code></pre> Source code in <code>qablet_contracts\\bnd\\zero.py</code> <pre><code>@dataclass\nclass Bond(EventsMixin):\n    \"\"\"A **zero coupon bond** pays a single fixed payment at a future time.\n\n    Args:\n        ccy: the currency of the bond.\n        maturity: the maturity of the bond.\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; Bond(\"USD\", datetime(2025, 3, 31)).print_events()\n              time op  quantity unit track\n        03/31/2025  +       1.0  USD\n    \"\"\"\n\n    ccy: str\n    maturity: datetime\n    track: str = \"\"\n\n    def events(self):\n        return [\n            {\n                \"track\": self.track,\n                \"time\": self.maturity,\n                \"op\": \"+\",\n                \"quantity\": 1,\n                \"unit\": self.ccy,\n            }\n        ]\n</code></pre>"},{"location":"examples/bond_zero/#qablet_contracts.bnd.zero.BondPut","title":"<code>BondPut</code>  <code>dataclass</code>","text":"<p>               Bases: <code>EventsMixin</code></p> <p>A zero coupon bond put offers the holder the option to sell a zero coupon bond for a fixed strike price, on the option maturity date.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the bond.</p> required <code>opt_maturity</code> <code>datetime</code> <p>the maturity of the option.</p> required <code>bond_maturity</code> <code>datetime</code> <p>the maturity of the bond.</p> required <code>strike</code> <code>float</code> <p>the option strike.</p> required <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; BondPut(\"USD\", datetime(2024, 9, 30), datetime(2025, 3, 31), 0.95).print_events()\n      time op  quantity unit track\n09/30/2024  &gt;      0.00  USD\n09/30/2024  +      0.95  USD\n03/31/2025  +     -1.00  USD\n</code></pre> Source code in <code>qablet_contracts\\bnd\\zero.py</code> <pre><code>@dataclass\nclass BondPut(EventsMixin):\n    \"\"\"A **zero coupon bond put** offers the holder the option to sell a zero coupon bond for\n    a fixed strike price, on the option maturity date.\n\n    Args:\n        ccy: the currency of the bond.\n        opt_maturity: the maturity of the option.\n        bond_maturity: the maturity of the bond.\n        strike: the option strike.\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; BondPut(\"USD\", datetime(2024, 9, 30), datetime(2025, 3, 31), 0.95).print_events()\n              time op  quantity unit track\n        09/30/2024  &gt;      0.00  USD\n        09/30/2024  +      0.95  USD\n        03/31/2025  +     -1.00  USD\n    \"\"\"\n\n    ccy: str\n    opt_maturity: datetime\n    bond_maturity: datetime\n    strike: float\n    track: str = \"\"\n\n    def events(self):\n        keys = [\"track\", \"time\", \"op\", \"quantity\", \"unit\"]\n        events_list = [\n            [self.track, self.opt_maturity, \"&gt;\", 0, self.ccy],\n            [self.track, self.opt_maturity, \"+\", self.strike, self.ccy],\n            [self.track, self.bond_maturity, \"+\", -1, self.ccy],\n        ]\n        return [dict(zip(keys, event)) for event in events_list]\n</code></pre>"},{"location":"examples/bond_zero/#qablet_contracts.bnd.zero.BondCall","title":"<code>BondCall</code>  <code>dataclass</code>","text":"<p>               Bases: <code>EventsMixin</code></p> <p>A zero coupon bond call offers the holder the option to buy a zero coupon bond for a fixed strike price, on the option maturity date.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the bond.</p> required <code>opt_maturity</code> <code>datetime</code> <p>the maturity of the option.</p> required <code>bond_maturity</code> <code>datetime</code> <p>the maturity of the bond.</p> required <code>strike</code> <code>float</code> <p>the option strike.</p> required <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; BondCall(\"USD\", datetime(2024, 9, 30), datetime(2025, 3, 31), 0.95).print_events()\n      time op  quantity unit track\n09/30/2024  &gt;      0.00  USD\n09/30/2024  +     -0.95  USD\n03/31/2025  +      1.00  USD\n</code></pre> Source code in <code>qablet_contracts\\bnd\\zero.py</code> <pre><code>@dataclass\nclass BondCall(EventsMixin):\n    \"\"\"A **zero coupon bond call** offers the holder the option to buy a zero coupon bond for\n    a fixed strike price, on the option maturity date.\n\n    Args:\n        ccy: the currency of the bond.\n        opt_maturity: the maturity of the option.\n        bond_maturity: the maturity of the bond.\n        strike: the option strike.\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; BondCall(\"USD\", datetime(2024, 9, 30), datetime(2025, 3, 31), 0.95).print_events()\n              time op  quantity unit track\n        09/30/2024  &gt;      0.00  USD\n        09/30/2024  +     -0.95  USD\n        03/31/2025  +      1.00  USD\n    \"\"\"\n\n    ccy: str\n    opt_maturity: datetime\n    bond_maturity: datetime\n    strike: float\n    track: str = \"\"\n\n    def events(self):\n        keys = [\"track\", \"time\", \"op\", \"quantity\", \"unit\"]\n        events_list = [\n            [self.track, self.opt_maturity, \"&gt;\", 0, self.ccy],\n            [self.track, self.opt_maturity, \"+\", -self.strike, self.ccy],\n            [self.track, self.bond_maturity, \"+\", 1, self.ccy],\n        ]\n        return [dict(zip(keys, event)) for event in events_list]\n</code></pre>"},{"location":"examples/equity_autocall/","title":"AutoCallable Note","text":"<p>This module contains examples of autocallable notes.</p>"},{"location":"examples/equity_autocall/#qablet_contracts.eq.autocall.DiscountCert","title":"<code>DiscountCert</code>  <code>dataclass</code>","text":"<p>               Bases: <code>EventsMixin</code></p> <p>An Autocallable Discount Certificate is called if the asset price is above the barrier level on any of the barrier observation dates. If called, the note pays the principal and the coupon accreted till the call date. Otherwise, at maturity, if the asset is above strike, it pays the principal and the coupon at maturity. If the asset is below strike, the principal payment is scaled down proportionately with the asset price.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the option.</p> required <code>asset_name</code> <code>str</code> <p>the name of the underlying asset.</p> required <code>initial_spot</code> <code>float</code> <p>the initial spot price of the asset.</p> required <code>strike</code> <code>float</code> <p>downside participation below this strike.</p> required <code>maturity</code> <code>datetime</code> <p>the maturity of the option in years.</p> required <code>barrier</code> <code>float</code> <p>the note is called above this barrier level.</p> required <code>barrier_dates</code> <code>List[datetime]</code> <p>the barrier observation points.</p> required <code>cpn_rate</code> <code>float</code> <p>the coupon rate.</p> required <code>notional</code> <code>float</code> <p>the notional amount.</p> <code>100.0</code> <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; start = datetime(2024, 3, 31)\n&gt;&gt;&gt; maturity = datetime(2024, 7, 31)\n&gt;&gt;&gt; barrier_dates = pd.date_range(start, maturity, freq=\"ME\", inclusive=\"right\")\n&gt;&gt;&gt; DiscountCert(\"USD\", \"AAPL\", 100, 80, start, maturity, 102, barrier_dates, 0.092)print_events()\n      time   op   quantity   unit track\n04/30/2024 call 100.836815    USD\n05/31/2024 call 101.680633    USD\n06/30/2024 call 102.531512    USD\n07/31/2024 call 103.389511    USD\n07/31/2024    +   1.000000 payoff\n</code></pre> Source code in <code>qablet_contracts\\eq\\autocall.py</code> <pre><code>@dataclass\nclass DiscountCert(EventsMixin):\n    \"\"\"An **Autocallable Discount Certificate** is called if the asset price is above the barrier level\n    on any of the barrier observation dates. If called, the note pays the principal and the coupon accreted\n    till the call date. Otherwise, at maturity, if the asset is above strike, it pays the principal and the\n    coupon at maturity. If the asset is below strike, the principal payment is scaled down proportionately\n    with the asset price.\n\n    Args:\n        ccy: the currency of the option.\n        asset_name: the name of the underlying asset.\n        initial_spot: the initial spot price of the asset.\n        strike: downside participation below this strike.\n        maturity: the maturity of the option in years.\n        barrier: the note is called above this barrier level.\n        barrier_dates: the barrier observation points.\n        cpn_rate: the coupon rate.\n        notional: the notional amount.\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; start = datetime(2024, 3, 31)\n        &gt;&gt;&gt; maturity = datetime(2024, 7, 31)\n        &gt;&gt;&gt; barrier_dates = pd.date_range(start, maturity, freq=\"ME\", inclusive=\"right\")\n        &gt;&gt;&gt; DiscountCert(\"USD\", \"AAPL\", 100, 80, start, maturity, 102, barrier_dates, 0.092)print_events()\n              time   op   quantity   unit track\n        04/30/2024 call 100.836815    USD\n        05/31/2024 call 101.680633    USD\n        06/30/2024 call 102.531512    USD\n        07/31/2024 call 103.389511    USD\n        07/31/2024    +   1.000000 payoff\n    \"\"\"\n\n    ccy: str\n    asset_name: str\n    initial_spot: float\n    strike: float\n    accrual_start: datetime\n    maturity: datetime\n    barrier: float\n    barrier_dates: List[datetime]\n    cpn_rate: float\n    notional: float = 100.0\n    track: str = \"\"\n\n    def events(self):\n        events = []\n        # Autocall events\n        for barrier_date in self.barrier_dates:\n            # daycount_fraction\n            frac = dcf(barrier_date, self.accrual_start)\n            events.append(\n                {\n                    \"track\": self.track,\n                    \"time\": barrier_date,\n                    \"op\": \"call\",\n                    \"quantity\": self.notional * np.exp(frac * self.cpn_rate),\n                    \"unit\": self.ccy,\n                }\n            )\n\n        # payoff at maturity\n        events.append(\n            {\n                \"track\": \"\",\n                \"time\": self.maturity,\n                \"op\": \"+\",\n                \"quantity\": 1.0,\n                \"unit\": \"payoff\",\n            }\n        )\n        return events\n\n    def fixed_payoff(self):\n        return self.notional * np.exp(\n            dcf(self.maturity, self.accrual_start) * self.cpn_rate\n        )\n\n    def expressions(self):\n        # Define the autocall condition\n        def ko_fn(inputs):\n            [S] = inputs\n            return [S &gt; (self.barrier * self.initial_spot / self.notional)]\n\n        call = {\n            \"type\": \"phrase\",\n            \"inp\": [self.asset_name],\n            \"fn\": ko_fn,\n        }\n\n        # Define the final payoff\n        def payoff_fn(inputs):\n            [s] = inputs\n            eq_pay = s * (self.notional / self.initial_spot)\n            return [\n                np.where(eq_pay &lt; self.strike, eq_pay, self.fixed_payoff())\n            ]\n\n        payoff = {\n            \"type\": \"phrase\",\n            \"inp\": [self.asset_name],\n            \"fn\": payoff_fn,\n        }\n\n        return {\"payoff\": payoff, \"call\": call}\n</code></pre>"},{"location":"examples/equity_autocall/#qablet_contracts.eq.autocall.ReverseCB","title":"<code>ReverseCB</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DiscountCert</code></p> <p>An Autocallable Reverse Convertible is called if the asset price is above the barrier level on any of the barrier observation dates. Otherwise, at maturity, if the asset is above strike, it pays the principal and the coupon at maturity. If the asset is below strike, the principal payment is scaled down proportionately with the asset price. The note pays periodic coupons until called or matured.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the option.</p> required <code>asset_name</code> <code>str</code> <p>the name of the underlying asset.</p> required <code>initial_spot</code> <code>float</code> <p>the initial spot price of the asset.</p> required <code>strike</code> <code>float</code> <p>downside participation below this strike.</p> required <code>maturity</code> <code>datetime</code> <p>the maturity of the option in years.</p> required <code>barrier</code> <code>float</code> <p>the note is called above this barrier level.</p> required <code>barrier_dates</code> <code>List[datetime]</code> <p>the barrier observation points.</p> required <code>cpn_rate</code> <code>float</code> <p>the coupon rate.</p> required <code>notional</code> <code>float</code> <p>the notional amount.</p> <code>100.0</code> <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; start = datetime(2024, 3, 31)\n&gt;&gt;&gt; maturity = datetime(2024, 7, 31)\n&gt;&gt;&gt; barrier_dates = pd.date_range(start, maturity, freq=\"ME\", inclusive=\"right\")\n&gt;&gt;&gt; ReverseCB(\"USD\", \"AAPL\", 100, 80, start, maturity, 102, barrier_dates, 0.10).print_events()\n      time   op   quantity   unit track\n04/30/2024    +   0.833333    USD\n04/30/2024 call 100.000000    USD\n05/31/2024    +   0.833333    USD\n05/31/2024 call 100.000000    USD\n06/30/2024    +   0.833333    USD\n06/30/2024 call 100.000000    USD\n07/31/2024    +   0.833333    USD\n07/31/2024 call 100.000000    USD\n07/31/2024    +   1.000000 payoff\n</code></pre> Source code in <code>qablet_contracts\\eq\\autocall.py</code> <pre><code>@dataclass\nclass ReverseCB(DiscountCert):\n    \"\"\"An **Autocallable Reverse Convertible** is called if the asset price is above the barrier level\n    on any of the barrier observation dates. Otherwise, at maturity, if the asset is above strike, it pays the principal and the\n    coupon at maturity. If the asset is below strike, the principal payment is scaled down proportionately\n    with the asset price. The note pays periodic coupons until called or matured.\n\n    Args:\n        ccy: the currency of the option.\n        asset_name: the name of the underlying asset.\n        initial_spot: the initial spot price of the asset.\n        strike: downside participation below this strike.\n        maturity: the maturity of the option in years.\n        barrier: the note is called above this barrier level.\n        barrier_dates: the barrier observation points.\n        cpn_rate: the coupon rate.\n        notional: the notional amount.\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; start = datetime(2024, 3, 31)\n        &gt;&gt;&gt; maturity = datetime(2024, 7, 31)\n        &gt;&gt;&gt; barrier_dates = pd.date_range(start, maturity, freq=\"ME\", inclusive=\"right\")\n        &gt;&gt;&gt; ReverseCB(\"USD\", \"AAPL\", 100, 80, start, maturity, 102, barrier_dates, 0.10).print_events()\n              time   op   quantity   unit track\n        04/30/2024    +   0.833333    USD\n        04/30/2024 call 100.000000    USD\n        05/31/2024    +   0.833333    USD\n        05/31/2024 call 100.000000    USD\n        06/30/2024    +   0.833333    USD\n        06/30/2024 call 100.000000    USD\n        07/31/2024    +   0.833333    USD\n        07/31/2024 call 100.000000    USD\n        07/31/2024    +   1.000000 payoff\n    \"\"\"\n\n    def events(self):\n        events = []\n        cpn_start_dates = [self.accrual_start] + list(self.barrier_dates[:-1])\n        # Autocall events\n        for start, end in zip(cpn_start_dates, self.barrier_dates):\n            # daycount_fraction\n            frac = dcf(end, start)\n            events.append(\n                {\n                    \"track\": self.track,\n                    \"time\": end,\n                    \"op\": \"+\",\n                    \"quantity\": self.notional * frac * self.cpn_rate,\n                    \"unit\": self.ccy,\n                }\n            )\n            events.append(\n                {\n                    \"track\": self.track,\n                    \"time\": end,\n                    \"op\": \"call\",\n                    \"quantity\": self.notional,\n                    \"unit\": self.ccy,\n                }\n            )\n\n        # payoff at maturity\n        events.append(\n            {\n                \"track\": \"\",\n                \"time\": self.maturity,\n                \"op\": \"+\",\n                \"quantity\": 1.0,\n                \"unit\": \"payoff\",\n            }\n        )\n        return events\n\n    def fixed_payoff(self):\n        return self.notional\n</code></pre>"},{"location":"examples/equity_barrier/","title":"Barrier Option","text":"<p>This module contains examples of barrier options.</p>"},{"location":"examples/equity_barrier/#qablet_contracts.eq.barrier.OptionKO","title":"<code>OptionKO</code>  <code>dataclass</code>","text":"<p>               Bases: <code>EventsMixin</code></p> <p>In a Dn/Out Option the contract is cancelled if the underlying asset price falls below the barrier level on any of the barrier observation dates. In an Up/Out Option the contract is cancelled if the underlying asset price rises above the barrier level on any of the observation dates.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the option.</p> required <code>asset_name</code> <code>str</code> <p>the name of the underlying asset.</p> required <code>strike</code> <code>float</code> <p>the option strike.</p> required <code>maturity</code> <code>datetime</code> <p>the maturity of the option in years.</p> required <code>is_call</code> <code>bool</code> <p>true if the option is a call.</p> required <code>barrier</code> <code>float</code> <p>the barrier level.</p> required <code>barrier_type</code> <code>str</code> <p>the type of barrier option, e.g \"Dn/Out\" or \"Up/Out\".</p> required <code>barrier_dates</code> <code>List[datetime]</code> <p>the barrier observation points.</p> required <code>rebate</code> <code>float</code> <p>the rebate amount paid at cancellation.</p> <code>0</code> <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; start = datetime(2024, 3, 31)\n&gt;&gt;&gt; maturity = datetime(2024, 9, 30)\n&gt;&gt;&gt; barrier_dates = pd.date_range(start, maturity, freq=\"2ME\")\n&gt;&gt;&gt; OptionKO(\"USD\", \"EQ\", 100, maturity, True, 102, \"Up/Out\", barrier_dates).print_events()\n      time op  quantity unit track\n03/31/2024 ko       0.0  USD\n05/31/2024 ko       0.0  USD\n07/31/2024 ko       0.0  USD\n09/30/2024 ko       0.0  USD\n09/30/2024  &gt;       0.0  USD\n09/30/2024  +    -100.0  USD\n09/30/2024  +       1.0   EQ\n</code></pre> Source code in <code>qablet_contracts\\eq\\barrier.py</code> <pre><code>@dataclass\nclass OptionKO(EventsMixin):\n    \"\"\"In a **Dn/Out Option** the contract is cancelled if the underlying asset price\n    falls below the barrier level on any of the barrier observation dates.\n    In an **Up/Out Option** the contract is cancelled if the underlying asset price\n    rises above the barrier level on any of the observation dates.\n\n    Args:\n        ccy: the currency of the option.\n        asset_name: the name of the underlying asset.\n        strike: the option strike.\n        maturity: the maturity of the option in years.\n        is_call: true if the option is a call.\n        barrier: the barrier level.\n        barrier_type: the type of barrier option, e.g \"Dn/Out\" or \"Up/Out\".\n        barrier_dates: the barrier observation points.\n        rebate: the rebate amount paid at cancellation.\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; start = datetime(2024, 3, 31)\n        &gt;&gt;&gt; maturity = datetime(2024, 9, 30)\n        &gt;&gt;&gt; barrier_dates = pd.date_range(start, maturity, freq=\"2ME\")\n        &gt;&gt;&gt; OptionKO(\"USD\", \"EQ\", 100, maturity, True, 102, \"Up/Out\", barrier_dates).print_events()\n              time op  quantity unit track\n        03/31/2024 ko       0.0  USD\n        05/31/2024 ko       0.0  USD\n        07/31/2024 ko       0.0  USD\n        09/30/2024 ko       0.0  USD\n        09/30/2024  &gt;       0.0  USD\n        09/30/2024  +    -100.0  USD\n        09/30/2024  +       1.0   EQ\n    \"\"\"\n\n    ccy: str\n    asset_name: str\n    strike: float\n    maturity: datetime\n    is_call: bool\n    barrier: float\n    barrier_type: str\n    barrier_dates: List[datetime]\n    rebate: float = 0\n    track: str = \"\"\n\n    def events(self):\n        events = []\n        for barrier_date in self.barrier_dates:\n            events.append(\n                {\n                    \"track\": self.track,\n                    \"time\": barrier_date,\n                    \"op\": \"ko\",\n                    \"quantity\": self.rebate,\n                    \"unit\": self.ccy,\n                }\n            )\n\n        vanilla_events = Option(\n            self.ccy,\n            self.asset_name,\n            self.strike,\n            self.maturity,\n            self.is_call,\n            self.track,\n        ).events()\n\n        events.extend(vanilla_events)\n        return events\n\n    def expressions(self):\n        \"\"\"Define the knockout expression (ko).\"\"\"\n        if self.barrier_type == \"Dn/Out\":\n\n            def ko_fn(inputs):\n                [S] = inputs\n                return [S &lt; self.barrier]\n        elif self.barrier_type == \"Up/Out\":\n\n            def ko_fn(inputs):\n                [S] = inputs\n                return [S &gt; self.barrier]\n        else:\n            raise ValueError(f\"Unknown barrier type: {self.barrier_type}\")\n\n        return {\n            \"ko\": {\n                \"type\": \"phrase\",\n                \"inp\": [self.asset_name],\n                \"fn\": ko_fn,\n            }\n        }\n</code></pre>"},{"location":"examples/equity_barrier/#qablet_contracts.eq.barrier.OptionKO.expressions","title":"<code>expressions()</code>","text":"<p>Define the knockout expression (ko).</p> Source code in <code>qablet_contracts\\eq\\barrier.py</code> <pre><code>def expressions(self):\n    \"\"\"Define the knockout expression (ko).\"\"\"\n    if self.barrier_type == \"Dn/Out\":\n\n        def ko_fn(inputs):\n            [S] = inputs\n            return [S &lt; self.barrier]\n    elif self.barrier_type == \"Up/Out\":\n\n        def ko_fn(inputs):\n            [S] = inputs\n            return [S &gt; self.barrier]\n    else:\n        raise ValueError(f\"Unknown barrier type: {self.barrier_type}\")\n\n    return {\n        \"ko\": {\n            \"type\": \"phrase\",\n            \"inp\": [self.asset_name],\n            \"fn\": ko_fn,\n        }\n    }\n</code></pre>"},{"location":"examples/equity_cliquet/","title":"Cliquet","text":"<p>This module contains examples of equity cliquet contracts.</p> <p>In an Accumulator the payoff depends on the asset price on several fixing dates \\(T_0 &lt; T_1 &lt; ... T_N\\).</p> <p>If the returns are given by</p> \\[ r_i = \\frac{S_{T_{i+1}}-S_{T_i}}{S_{T_i}} \\] <p>Then contract has a single payoff at \\(T_N\\), given by</p> \\[ \\max \\left( floor_G, \\Sigma_0^{N-1} \\max(\\min(r_i, cap_L), floor_L) \\right) \\]"},{"location":"examples/equity_cliquet/#qablet_contracts.eq.cliquet.Accumulator","title":"<code>Accumulator</code>  <code>dataclass</code>","text":"<p>               Bases: <code>EventsMixin</code></p> <p>In an Accumulator the asset returns are calculated over a series of consecutive periods. Each return is subject to a local floor and cap, then accumulated by adding, and finally the accumulated payoff is subject to a global floor.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the bond.</p> required <code>asset_name</code> <code>str</code> <p>the name of the underlying asset.</p> required <code>fix_dates</code> <code>List[datetime]</code> <p>the fixing times of the cliquet.</p> required <code>global_floor</code> <code>float</code> <p>the global floor of the cliquet.</p> required <code>local_floor</code> <code>float</code> <p>the local floor of the cliquet.</p> required <code>local_cap</code> <code>float</code> <p>the local cap of the cliquet.</p> required <code>notional</code> <code>float</code> <p>the notional of the cliquet.</p> <code>100.0</code> <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fix_dates = pd.bdate_range(datetime(2021, 12, 31), datetime(2024, 12, 31), freq=\"2BQE\")\n&gt;&gt;&gt; Accumulator(\"USD\", \"SPX\", fix_dates, 0.0, -0.03, 0.05).print_events()\n      time  op  quantity   unit track\n12/31/2021 NaN       0.0  start   NaN\n06/30/2022 NaN       0.0 addfix   NaN\n12/30/2022 NaN       0.0 addfix   NaN\n06/30/2023 NaN       0.0 addfix   NaN\n12/29/2023 NaN       0.0 addfix   NaN\n06/28/2024 NaN       0.0 addfix   NaN\n12/31/2024 NaN       0.0 addfix   NaN\n12/31/2024   &gt;       0.0    USD\n12/31/2024   +     100.0    ACC\n</code></pre> Source code in <code>qablet_contracts\\eq\\cliquet.py</code> <pre><code>@dataclass\nclass Accumulator(EventsMixin):\n    \"\"\"In an **Accumulator** the asset returns are calculated over a series of consecutive periods.\n    Each return is subject to a local floor and cap, then accumulated by adding, and finally the\n    accumulated payoff is subject to a global floor.\n\n    Args:\n        ccy: the currency of the bond.\n        asset_name: the name of the underlying asset.\n        fix_dates: the fixing times of the cliquet.\n        global_floor: the global floor of the cliquet.\n        local_floor: the local floor of the cliquet.\n        local_cap: the local cap of the cliquet.\n        notional: the notional of the cliquet.\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; fix_dates = pd.bdate_range(datetime(2021, 12, 31), datetime(2024, 12, 31), freq=\"2BQE\")\n        &gt;&gt;&gt; Accumulator(\"USD\", \"SPX\", fix_dates, 0.0, -0.03, 0.05).print_events()\n              time  op  quantity   unit track\n        12/31/2021 NaN       0.0  start   NaN\n        06/30/2022 NaN       0.0 addfix   NaN\n        12/30/2022 NaN       0.0 addfix   NaN\n        06/30/2023 NaN       0.0 addfix   NaN\n        12/29/2023 NaN       0.0 addfix   NaN\n        06/28/2024 NaN       0.0 addfix   NaN\n        12/31/2024 NaN       0.0 addfix   NaN\n        12/31/2024   &gt;       0.0    USD\n        12/31/2024   +     100.0    ACC\n    \"\"\"\n\n    ccy: str\n    asset_name: str\n    fix_dates: List[datetime]\n    global_floor: float\n    local_floor: float\n    local_cap: float\n    notional: float = 100.0\n    track: str = \"\"\n    state: dict = field(default_factory=dict)\n\n    def events(self):\n        maturity = self.fix_dates[-1]\n\n        events = [\n            {\n                \"track\": None,\n                \"time\": self.fix_dates[0],\n                \"op\": None,\n                \"quantity\": 0,\n                \"unit\": \"start\",  # start accumulator\n            }\n        ]\n        for fixing_time in self.fix_dates[1:]:\n            events.append(\n                {\n                    \"track\": None,\n                    \"time\": fixing_time,\n                    \"op\": None,\n                    \"quantity\": 0,\n                    \"unit\": \"addfix\",  # update accumulator\n                }\n            )\n        events.append(\n            {\n                \"track\": self.track,\n                \"time\": maturity,\n                \"op\": \"&gt;\",  # global floor\n                \"quantity\": self.global_floor,\n                \"unit\": self.ccy,\n            }\n        )\n        events.append(\n            {\n                \"track\": self.track,\n                \"time\": maturity,\n                \"op\": \"+\",  # pay the accumulated amount\n                \"quantity\": self.notional,\n                \"unit\": \"ACC\",\n            }\n        )\n        return events\n\n    def expressions(self):\n        last_acc = self.state.get(\"ACC\", 0.0)\n\n        if \"S_PREV\" in self.state:\n\n            def accumulator_init_fn(inputs):\n                [s] = inputs\n                return [last_acc, self.state[\"S_PREV\"]]  # [ACC, S_PREV]\n        else:\n\n            def accumulator_init_fn(inputs):\n                [s] = inputs\n                return [last_acc, s]  # [ACC, S_PREV]\n\n        def accumulator_update_fn(inputs):\n            [s, s_prev, a] = inputs\n\n            ret = s / s_prev - 1.0  # ret = S / S_PREV - 1\n            ret = np.maximum(self.local_floor, ret)\n            ret = np.minimum(self.local_cap, ret)\n\n            return [a + ret, s]  # [ACC, S_PREV]\n\n        return {\n            \"start\": {\n                \"type\": \"snapper\",\n                \"inp\": [self.asset_name],\n                \"fn\": accumulator_init_fn,\n                \"out\": [\"ACC\", \"S_PREV\"],\n            },\n            \"addfix\": {\n                \"type\": \"snapper\",\n                \"inp\": [self.asset_name, \"S_PREV\", \"ACC\"],\n                \"fn\": accumulator_update_fn,\n                \"out\": [\"ACC\", \"S_PREV\"],\n            },\n        }\n</code></pre>"},{"location":"examples/equity_fwdoption/","title":"Forward Option","text":"<p>This module contains examples of forward starting options.</p>"},{"location":"examples/equity_fwdoption/#qablet_contracts.eq.forward.ForwardOption","title":"<code>ForwardOption</code>  <code>dataclass</code>","text":"<p>               Bases: <code>EventsMixin</code></p> <p>In a Forward Starting Option the strike price is set on a future date as a predetermine percent of the stock price on the strike fixing date.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the option.</p> required <code>asset_name</code> <code>str</code> <p>the name of the underlying asset.</p> required <code>strike_rate</code> <code>float</code> <p>the option strike in percent of fixing.</p> required <code>strike_date</code> <code>datetime</code> <p>the datetime at which the strike is fixed.</p> required <code>maturity</code> <code>datetime</code> <p>the maturity of the option in years.</p> required <code>is_call</code> <code>bool</code> <p>true if the option is a call.</p> required <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; timetable = ForwardOption( \"USD\", \"SPX\", 1.0,\ndatetime(2024, 3, 31), datetime(2024, 9, 30), True).print_events()\n      time  op  quantity   unit track\n03/31/2024 NaN       0.0 .fix_K   NaN\n09/30/2024   &gt;       0.0    USD\n09/30/2024   +      -1.0     .K\n09/30/2024   +       1.0    SPX\n</code></pre> Source code in <code>qablet_contracts\\eq\\forward.py</code> <pre><code>@dataclass\nclass ForwardOption(EventsMixin):\n    \"\"\"In a **Forward Starting Option** the strike price is set on a future date as\n    a predetermine percent of the stock price on the strike fixing date.\n\n    Args:\n        ccy: the currency of the option.\n        asset_name: the name of the underlying asset.\n        strike_rate: the option strike in percent of fixing.\n        strike_date: the datetime at which the strike is fixed.\n        maturity: the maturity of the option in years.\n        is_call: true if the option is a call.\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; timetable = ForwardOption( \"USD\", \"SPX\", 1.0,\n        datetime(2024, 3, 31), datetime(2024, 9, 30), True).print_events()\n              time  op  quantity   unit track\n        03/31/2024 NaN       0.0 .fix_K   NaN\n        09/30/2024   &gt;       0.0    USD\n        09/30/2024   +      -1.0     .K\n        09/30/2024   +       1.0    SPX\n    \"\"\"\n\n    ccy: str\n    asset_name: str\n    strike_rate: float\n    strike_date: datetime\n    maturity: datetime\n    is_call: bool\n    track: str = \"\"\n\n    def events(self):\n        sign = 1 if self.is_call else -1\n        return [\n            {\n                \"track\": None,\n                \"time\": self.strike_date,\n                \"op\": None,\n                \"quantity\": 0,\n                \"unit\": f\"{self.track}.fix_K\",  # set the strike\n            },\n            {\n                \"track\": self.track,\n                \"time\": self.maturity,\n                \"op\": \"&gt;\",\n                \"quantity\": 0,\n                \"unit\": self.ccy,\n            },\n            {\n                \"track\": self.track,\n                \"time\": self.maturity,\n                \"op\": \"+\",\n                \"quantity\": -self.strike_rate * sign,\n                \"unit\": f\"{self.track}.K\",\n            },\n            {\n                \"track\": self.track,\n                \"time\": self.maturity,\n                \"op\": \"+\",\n                \"quantity\": sign,\n                \"unit\": self.asset_name,\n            },\n        ]\n\n    def expressions(self):\n        # Define the strike expression, return the spot itself.\n        def strike_fn(inputs):\n            return inputs\n\n        return {\n            f\"{self.track}.fix_K\": {\n                \"type\": \"snapper\",\n                \"inp\": [self.asset_name],\n                \"fn\": strike_fn,\n                \"out\": [f\"{self.track}.K\"],\n            }\n        }\n</code></pre>"},{"location":"examples/equity_rainbow/","title":"Rainbow Option","text":"<p>This module contains examples of equity rainbow options.</p>"},{"location":"examples/equity_rainbow/#qablet_contracts.eq.rainbow.Rainbow","title":"<code>Rainbow</code>  <code>dataclass</code>","text":"<p>               Bases: <code>EventsMixin</code></p> <p>A Rainbow Call Option offers the holder the option to buy the best of a list of stocks (or none) for corresponding fixed strike prices, on the option maturity date. Similarly, a Rainbow Put Option offers the holder the option to sell the worst of a list of stocks (or none) for corresponding fixed strike prices.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the option.</p> required <code>asset_names</code> <code>List[str]</code> <p>the name of the underlying assets.</p> required <code>strikes</code> <code>List[float]</code> <p>the option strikes.</p> required <code>notional</code> <code>float</code> <p>the notional of the option.</p> required <code>maturity</code> <code>datetime</code> <p>the maturity of the option.</p> required <code>is_call</code> <code>bool</code> <p>true if the option is a call.</p> required <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assets = [\"SPX\", \"FTSE\", \"N225\"]\n&gt;&gt;&gt; strikes = [5087, 7684, 39100]\n&gt;&gt;&gt; Rainbow(\"USD\", assets, strikes, 100_000, datetime(2024, 3, 31), True).print_events()\n      time op       quantity unit track\n03/31/2024  + -100000.000000  USD\n03/31/2024  &gt;      19.657952  SPX\n03/31/2024  &gt;      13.014055 FTSE\n03/31/2024  &gt;       2.557545 N225\n03/31/2024  +  100000.000000  USD\n</code></pre> Source code in <code>qablet_contracts\\eq\\rainbow.py</code> <pre><code>@dataclass\nclass Rainbow(EventsMixin):\n    \"\"\"A **Rainbow Call Option** offers the holder the option to buy the best of\n    a list of stocks (or none) for corresponding fixed strike prices, on the option maturity date.\n    Similarly, a **Rainbow Put Option** offers the holder the option to sell the worst of\n    a list of stocks (or none) for corresponding fixed strike prices.\n\n    Args:\n        ccy: the currency of the option.\n        asset_names: the name of the underlying assets.\n        strikes: the option strikes.\n        notional: the notional of the option.\n        maturity: the maturity of the option.\n        is_call: true if the option is a call.\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; assets = [\"SPX\", \"FTSE\", \"N225\"]\n        &gt;&gt;&gt; strikes = [5087, 7684, 39100]\n        &gt;&gt;&gt; Rainbow(\"USD\", assets, strikes, 100_000, datetime(2024, 3, 31), True).print_events()\n              time op       quantity unit track\n        03/31/2024  + -100000.000000  USD\n        03/31/2024  &gt;      19.657952  SPX\n        03/31/2024  &gt;      13.014055 FTSE\n        03/31/2024  &gt;       2.557545 N225\n        03/31/2024  +  100000.000000  USD\n    \"\"\"\n\n    ccy: str\n    asset_names: List[str]\n    strikes: List[float]\n    notional: float\n    maturity: datetime\n    is_call: bool\n    track: str = \"\"\n\n    def events(self):\n        sign = 1 if self.is_call else -1\n        # Pay the initial strike\n        events = [\n            {\n                \"track\": \"\",\n                \"time\": self.maturity,\n                \"op\": \"+\",\n                \"quantity\": -self.notional * sign,\n                \"unit\": self.ccy,\n            },\n        ]\n\n        # Options to receive any of the assets\n        for asset, strike in zip(self.asset_names, self.strikes):\n            events.append(\n                {\n                    \"track\": \"\",\n                    \"time\": self.maturity,\n                    \"op\": \"&gt;\",\n                    \"quantity\": self.notional / strike * sign,\n                    \"unit\": asset,\n                }\n            )\n\n        # Otherwise receive the notional back\n        events.append(\n            {\n                \"track\": \"\",\n                \"time\": self.maturity,\n                \"op\": \"+\",\n                \"quantity\": self.notional * sign,\n                \"unit\": self.ccy,\n            }\n        )\n        return events\n</code></pre>"},{"location":"examples/equity_vanilla/","title":"Vanilla Option","text":"<p>This module contains examples of equity vanilla options.</p>"},{"location":"examples/equity_vanilla/#qablet_contracts.eq.vanilla.Option","title":"<code>Option</code>  <code>dataclass</code>","text":"<p>               Bases: <code>EventsMixin</code></p> <p>An European Call Option offers the holder the option to buy a stock for a fixed strike price, on the option maturity date. Similarly, a Put Option offers the holder the option to sell a stock for a fixed strike price.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the option.</p> required <code>asset_name</code> <code>str</code> <p>the name of the underlying asset.</p> required <code>strike</code> <code>float</code> <p>the option strike.</p> required <code>maturity</code> <code>datetime</code> <p>the maturity of the option.</p> required <code>is_call</code> <code>bool</code> <p>true if the option is a call.</p> required <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <p>Call:</p> <pre><code>&gt;&gt;&gt; Option(\"USD\", \"SPX\", 2900, datetime(2024, 3, 31), True).print_events()\n    time   op  quantity unit track\n03/31/2024  &gt;       0.0  USD\n03/31/2024  +   -2900.0  USD\n03/31/2024  +       1.0  SPX\n</code></pre> <p>Put:</p> <pre><code>&gt;&gt;&gt; Option(\"USD\", \"SPX\", 2900, datetime(2024, 3, 31), False).print_events()\n      time op  quantity unit track\n03/31/2024  &gt;       0.0  USD\n03/31/2024  +    2900.0  USD\n03/31/2024  +      -1.0  SPX\n</code></pre> Source code in <code>qablet_contracts\\eq\\vanilla.py</code> <pre><code>@dataclass\nclass Option(EventsMixin):\n    \"\"\"An **European Call Option** offers the holder the option to buy a stock for\n    a fixed strike price, on the option maturity date.\n    Similarly, a **Put Option** offers the holder the option to sell a stock for\n    a fixed strike price.\n\n    Args:\n        ccy: the currency of the option.\n        asset_name: the name of the underlying asset.\n        strike: the option strike.\n        maturity: the maturity of the option.\n        is_call: true if the option is a call.\n        track: an optional identifier for the contract.\n\n    Examples:\n        Call:\n        &gt;&gt;&gt; Option(\"USD\", \"SPX\", 2900, datetime(2024, 3, 31), True).print_events()\n            time   op  quantity unit track\n        03/31/2024  &gt;       0.0  USD\n        03/31/2024  +   -2900.0  USD\n        03/31/2024  +       1.0  SPX\n\n        Put:\n        &gt;&gt;&gt; Option(\"USD\", \"SPX\", 2900, datetime(2024, 3, 31), False).print_events()\n              time op  quantity unit track\n        03/31/2024  &gt;       0.0  USD\n        03/31/2024  +    2900.0  USD\n        03/31/2024  +      -1.0  SPX\n    \"\"\"\n\n    ccy: str\n    asset_name: str\n    strike: float\n    maturity: datetime\n    is_call: bool\n    track: str = \"\"\n\n    def events(self):\n        sign = 1 if self.is_call else -1\n        return [\n            {\n                \"track\": self.track,\n                \"time\": self.maturity,\n                \"op\": \"&gt;\",\n                \"quantity\": 0,\n                \"unit\": self.ccy,\n            },\n            {\n                \"track\": self.track,\n                \"time\": self.maturity,\n                \"op\": \"+\",\n                \"quantity\": -self.strike * sign,\n                \"unit\": self.ccy,\n            },\n            {\n                \"track\": self.track,\n                \"time\": self.maturity,\n                \"op\": \"+\",\n                \"quantity\": sign,\n                \"unit\": self.asset_name,\n            },\n        ]\n</code></pre>"},{"location":"examples/rate_swap/","title":"Swaps","text":"<p>This module contains examples of interest rate swaps.</p>"},{"location":"examples/rate_swap/#qablet_contracts.ir.swap.Swap","title":"<code>Swap</code>  <code>dataclass</code>","text":"<p>               Bases: <code>EventsMixin</code></p> <p>In a Vanilla Swap, at the end of each period the holder pays a fixed rate and receives a floating rate. In this simple version the floating rate payment is replaced by receiving notional at the beginning of the period and paying the notional at the end of the period.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the swap.</p> required <code>dates</code> <code>List[datetime]</code> <p>the period datetimes of the swap, including the inception and maturity.</p> required <code>strike_rate</code> <code>float</code> <p>the strike rate of the swaption (in units, i.e. 0.02 means 200 bps).</p> required <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dates = pd.bdate_range(datetime(2023, 12, 31), datetime(2024, 12, 31), freq=\"2QE\")\n&gt;&gt;&gt; Swap(\"USD\", dates, strike_rate = 0.03).print_events()\n      time op  quantity unit track\n12/31/2023  +     1.000  USD  .swp\n06/30/2024  +    -1.015  USD  .swp\n06/30/2024  +     1.000  USD  .swp\n12/31/2024  +    -1.015  USD  .swp\n</code></pre> Source code in <code>qablet_contracts\\ir\\swap.py</code> <pre><code>@dataclass\nclass Swap(EventsMixin):\n    \"\"\"In a **Vanilla Swap**, at the end of each period the holder pays a fixed rate and receives a floating rate.\n    In this simple version the floating rate payment is replaced by receiving notional at the beginning of the period\n    and paying the notional at the end of the period.\n\n    Args:\n        ccy: the currency of the swap.\n        dates: the period datetimes of the swap, including the inception and maturity.\n        strike_rate: the strike rate of the swaption (in units, i.e. 0.02 means 200 bps).\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; dates = pd.bdate_range(datetime(2023, 12, 31), datetime(2024, 12, 31), freq=\"2QE\")\n        &gt;&gt;&gt; Swap(\"USD\", dates, strike_rate = 0.03).print_events()\n              time op  quantity unit track\n        12/31/2023  +     1.000  USD  .swp\n        06/30/2024  +    -1.015  USD  .swp\n        06/30/2024  +     1.000  USD  .swp\n        12/31/2024  +    -1.015  USD  .swp\n    \"\"\"\n\n    ccy: str\n    dates: List[datetime]\n    strike_rate: float\n    track: str = \"\"\n\n    def events(self):\n        events = []\n        # payment events\n        for start, end in zip(self.dates[0:-1], self.dates[1:]):\n            events.extend(\n                simple_swap_period(\n                    self.ccy, start, end, self.strike_rate, self.track + \".swp\"\n                )\n            )\n\n        return events\n</code></pre>"},{"location":"examples/rate_swap/#qablet_contracts.ir.swap.simple_swap_period","title":"<code>simple_swap_period(ccy, start, end, fixed_rate, track='')</code>","text":"<p>Simple representation of a swap period, paying fixed, receiving floating rate.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the swap.</p> required <code>start</code> <code>datetime</code> <p>the start of the period.</p> required <code>end</code> <code>datetime</code> <p>the end of the period.</p> required <code>fixed_rate</code> <code>float</code> <p>the fixed annual rate of the swap.</p> required <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> Source code in <code>qablet_contracts\\ir\\swap.py</code> <pre><code>def simple_swap_period(\n    ccy: str,\n    start: datetime,\n    end: datetime,\n    fixed_rate: float,\n    track: str = \"\",\n) -&gt; list:\n    \"\"\"Simple representation of a swap period, paying fixed, receiving floating rate.\n\n    Args:\n        ccy: the currency of the swap.\n        start: the start of the period.\n        end: the end of the period.\n        fixed_rate: the fixed annual rate of the swap.\n        track: an optional identifier for the contract.\n    \"\"\"\n    return [\n        {\n            \"track\": track,\n            \"time\": start,\n            \"op\": \"+\",\n            \"quantity\": 1,\n            \"unit\": ccy,\n        },\n        {\n            \"track\": track,\n            \"time\": end,\n            \"op\": \"+\",\n            \"quantity\": -1 - fixed_rate * dcf(end, start),\n            \"unit\": ccy,\n        },\n    ]\n</code></pre>"},{"location":"examples/rate_swaption/","title":"Swaptions","text":"<p>This module contains examples of interest rate swaptions.</p>"},{"location":"examples/rate_swaption/#qablet_contracts.ir.swaption.Swaption","title":"<code>Swaption</code>  <code>dataclass</code>","text":"<p>               Bases: <code>EventsMixin</code></p> <p>A Vanilla Swaption. In a Vanilla swaption the holder gets the opportunity to enter into the swap at the beginning of the first period.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the swap.</p> required <code>dates</code> <code>List[datetime]</code> <p>the period datetimes of the underlying swap, including the inception and maturity.</p> required <code>strike_rate</code> <code>float</code> <p>the strike rate of the swaption (in units, i.e. 0.02 means 200 bps).</p> required <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dates = pd.bdate_range(datetime(2023, 12, 31), datetime(2024, 12, 31), freq=\"2QE\")\n&gt;&gt;&gt; Swap(\"USD\", dates, strike_rate = 0.03).print_events()\n      time op  quantity unit track\n12/31/2023  &gt;     1.000 .swp  .opt\n12/31/2023  +     1.000  USD  .swp\n06/30/2024  +    -1.015  USD  .swp\n06/30/2024  +     1.000  USD  .swp\n12/31/2024  +    -1.015  USD  .swp\n</code></pre> Source code in <code>qablet_contracts\\ir\\swaption.py</code> <pre><code>@dataclass\nclass Swaption(EventsMixin):\n    \"\"\"A **Vanilla Swaption**.\n    In a Vanilla swaption the holder gets the opportunity to enter into the swap at the beginning of the first period.\n\n    Args:\n        ccy: the currency of the swap.\n        dates: the period datetimes of the underlying swap, including the inception and maturity.\n        strike_rate: the strike rate of the swaption (in units, i.e. 0.02 means 200 bps).\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; dates = pd.bdate_range(datetime(2023, 12, 31), datetime(2024, 12, 31), freq=\"2QE\")\n        &gt;&gt;&gt; Swap(\"USD\", dates, strike_rate = 0.03).print_events()\n              time op  quantity unit track\n        12/31/2023  &gt;     1.000 .swp  .opt\n        12/31/2023  +     1.000  USD  .swp\n        06/30/2024  +    -1.015  USD  .swp\n        06/30/2024  +     1.000  USD  .swp\n        12/31/2024  +    -1.015  USD  .swp\n    \"\"\"\n\n    ccy: str\n    dates: List[datetime]\n    strike_rate: float\n    track: str = \"\"\n\n    def events(self):\n        # option expiration event at beginning of the swap\n        events = [\n            {\n                \"track\": self.track + \".opt\",\n                \"time\": self.dates[0],\n                \"op\": \"&gt;\",\n                \"quantity\": 1,\n                \"unit\": self.track + \".swp\",\n            }\n        ]\n        # payment events for the underlying swap\n        for start, end in zip(self.dates[0:-1], self.dates[1:]):\n            events.extend(\n                simple_swap_period(\n                    self.ccy, start, end, self.strike_rate, self.track + \".swp\"\n                )\n            )\n\n        return events\n</code></pre>"},{"location":"examples/rate_swaption/#qablet_contracts.ir.swaption.BermudaSwaption","title":"<code>BermudaSwaption</code>  <code>dataclass</code>","text":"<p>               Bases: <code>EventsMixin</code></p> <p>In a Co-terminal Bermuda Swaption, the holder can exercise his option at the beginning of each swap period. If exercised, the holder pays and receives all remaining payments of the swap. If not exercised, there are no payments in the next swap period. Irrespective of the time of exercise, the swap terminates at the same date.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the swap.</p> required <code>dates</code> <code>List[datetime]</code> <p>the period datetimes of the underlying swap, including the inception and maturity.</p> required <code>strike_rate</code> <code>float</code> <p>the strike rate of the swaption (in units, i.e. 0.02 means 200 bps).</p> required <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dates = pd.bdate_range(datetime(2023, 12, 31), datetime(2024, 12, 31), freq=\"2QE\")\n&gt;&gt;&gt; Swap(\"USD\", dates, strike_rate = 0.03).print_events()\n      time op  quantity unit track\n12/31/2023  &gt;     1.000 .swp  .opt\n12/31/2023  +     1.000  USD  .swp\n06/30/2024  +    -1.015  USD  .swp\n06/30/2024  &gt;     1.000 .swp  .opt\n06/30/2024  +     1.000  USD  .swp\n12/31/2024  +    -1.015  USD  .swp\n</code></pre> Source code in <code>qablet_contracts\\ir\\swaption.py</code> <pre><code>@dataclass\nclass BermudaSwaption(EventsMixin):\n    \"\"\"In a **Co-terminal Bermuda Swaption**, the holder can exercise his option at the beginning of each swap period.\n    If exercised, the holder pays and receives all remaining payments of the swap. If not exercised, there are\n    no payments in the next swap period. Irrespective of the time of exercise, the swap terminates at the same date.\n\n    Args:\n        ccy: the currency of the swap.\n        dates: the period datetimes of the underlying swap, including the inception and maturity.\n        strike_rate: the strike rate of the swaption (in units, i.e. 0.02 means 200 bps).\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; dates = pd.bdate_range(datetime(2023, 12, 31), datetime(2024, 12, 31), freq=\"2QE\")\n        &gt;&gt;&gt; Swap(\"USD\", dates, strike_rate = 0.03).print_events()\n              time op  quantity unit track\n        12/31/2023  &gt;     1.000 .swp  .opt\n        12/31/2023  +     1.000  USD  .swp\n        06/30/2024  +    -1.015  USD  .swp\n        06/30/2024  &gt;     1.000 .swp  .opt\n        06/30/2024  +     1.000  USD  .swp\n        12/31/2024  +    -1.015  USD  .swp\n    \"\"\"\n\n    ccy: str\n    dates: List[datetime]\n    strike_rate: float\n    track: str = \"\"\n\n    def events(self):\n        events = []\n        for start, end in zip(self.dates[0:-1], self.dates[1:]):\n            # option expiration event before each period\n            events.append(\n                {\n                    \"track\": self.track + \".opt\",\n                    \"time\": start,\n                    \"op\": \"&gt;\",\n                    \"quantity\": 1,\n                    \"unit\": self.track + \".swp\",\n                }\n            )\n            # payment event for the underlying swap\n            events.extend(\n                simple_swap_period(\n                    self.ccy, start, end, self.strike_rate, self.track + \".swp\"\n                )\n            )\n\n        return events\n</code></pre>"},{"location":"specifications/operations/","title":"Operations","text":"<p>The op column contains a string which can be <code>+</code>, <code>&gt;</code>, <code>&lt;</code>, or a condition.</p>"},{"location":"specifications/operations/#payment","title":"Payment","text":"<pre><code>+\n</code></pre> <p><code>+</code> in the ops column indicates that the contract holder will receive the payment specified by the quantity and the unit, and then continue to receive whatever else is further down in the timetable in the same track.</p> <p>Example: A bond paying 5% semi-annually and maturing in two years. </p> <pre><code>      time op  quantity unit track\n06/30/2024  +     0.025  USD\n12/31/2024  +     0.025  USD\n06/30/2025  +     0.025  USD\n12/31/2025  +     1.025  USD\n</code></pre>"},{"location":"specifications/operations/#choice-of-holder","title":"Choice of holder","text":"<pre><code>&gt;\n</code></pre> <p><code>&gt;</code> in the ops column indicates that the contract holder can choose from the following two options</p> <ul> <li>receive the payment specified by the quantity and the unit, and then terminate the contract.</li> <li>or, instead of that payment, receive whatever else is further down in the timetable in the same track.</li> </ul> <p>Example: An European Call Option with strike 2900, expiring in 2024-03-31.</p> <pre><code>      time op  quantity unit track\n03/31/2024  &gt;       0.0  USD\n03/31/2024  +   -2900.0  USD\n03/31/2024  +       1.0  SPX\n</code></pre> <p>Note</p> <p>A choice is different from a condition. In a choice, the holder of the contract (or counterparty) makes a decision. This decision takes future expectations into account, i.e. what is coming further down in the timetable. For the holder's choice, a reasonable model would choose the option with a greater expected value of future events.</p>"},{"location":"specifications/operations/#choice-of-counterparty","title":"Choice of counterparty","text":"<pre><code>&lt;\n</code></pre> <p><code>&lt;</code> in the ops column indicates that the counterparty can choose from the following two options</p> <ul> <li>pay the holder the payment specified by the quantity and the unit, and then terminate the contract.</li> <li>or, instead of that payment, pay the holder whatever else is further down in the timetable in the same track.</li> </ul> <p>Example: A callable bond, paying 5% USD semi-annually, maturing in two years, and callable at the end of the first year.</p> <pre><code>      time op  quantity unit track\n06/30/2024  +     0.025  USD\n12/31/2024  +     0.025  USD\n12/31/2024  &lt;     1.000  USD\n06/30/2025  +     0.025  USD\n12/31/2025  +     1.025  USD\n</code></pre>"},{"location":"specifications/operations/#condition","title":"Condition","text":"<pre><code>ko\n</code></pre> <p>Any other string in the <code>op</code> column is assumed to be a phrase.</p> <ul> <li>If the phrase evaluates to true, the holder will receive the payment specified by the quantity and the unit, and then terminate the contract.</li> <li>If the phrase evaluates to false, then instead of that payment, holder will receive whatever else is further down in the timetable in the same track.</li> <li>If the phrase returns a float array instead of a bool array, the holder will receive a weighted sum of both outcomes.</li> </ul> <p>Example: knock-in or knock-out events in a barrier option. In the example below <code>ko</code> is a phrase that describes the barrier condition. If the condition is met the option is knocked out with a rebate of 1.0. If the barrier is not met, the contract continues further down the track.</p> <pre><code>      time op  quantity unit track\n03/31/2024 ko       0.0  USD\n05/31/2024 ko       0.0  USD\n07/31/2024 ko       0.0  USD\n09/30/2024 ko       0.0  USD\n09/30/2024  &gt;       0.0  USD\n09/30/2024  +    -100.0  USD\n09/30/2024  +       1.0   EQ\n</code></pre> <p>See a complete example in Barrier Options.</p>"},{"location":"specifications/operations/#snapper","title":"Snapper","text":"<p>If the unit is a Snapper, i.e. a path dependent calculation to be performed at that time, then op should be <code>None</code> or <code>\"s\"</code>.</p>"},{"location":"specifications/phrase/","title":"Expressions","text":"<p>The event table often requires one or more of the following to capture the features of contract.</p> <ul> <li>A Phrase that represents a value calculated from one or more assets. e.g. calculating the barrier condition in a knock out option.</li> <li>A Snapper that represents a path dependent calculation, e.g. calculating returns in an equity cliquet.</li> </ul>"},{"location":"specifications/phrase/#phrase","title":"Phrase","text":"<p>A Phrase is defined with three parameters.</p> <ul> <li>type, which must be \"phrase\"</li> <li>inp, a list of inputs to the phrase fn. An input can be an asset, such as \"SPX\", whose value comes from the model. It can also be a snap which has been stored as a result of previous snapper operation. It can also be another phrase.</li> <li>fn, a python function that takes a list of inputs, and returns a list of outputs. The length of expected inputs list must match the length of inp, while the length of the output list must be exactly one.</li> </ul> <p>e.g. for a Down-and-Out Barrier Option the knock out condition <code>ko</code> is defined as <pre><code>def ko_fn(inputs):\n    [S] = inputs\n    return [S &lt; barrier]\n\n\"ko\": {\n    \"type\": \"phrase\",\n    \"inp\": [asset_name],\n    \"fn\": ko_fn,\n}\n</code></pre></p> <p>and used in the timetable as an <code>op</code> <pre><code>      time op  quantity unit track\n03/31/2024 ko       0.0  USD\n</code></pre></p> <p>See Barrier Option for more on this example.</p>"},{"location":"specifications/phrase/#function-signature","title":"Function Signature","text":"<p>The function should expect that inputs is a list of items. </p> <ul> <li>The length of the list will match the length of inp.</li> <li>Each item in the list can be a float, or a 1-D numpy array of size 1 or N (where N is the number of Monte-Carlo paths, or the length of the Finite Difference grid's asset-axis).</li> </ul> <p>The function should return a list of items.</p> <ul> <li>For a phrase the length of the output list must be exactly one, while for a snapper the length of the output list must match the length of out.</li> <li>Each item in the list should be a float, or a 1-D numpy array of size 1 or N. This is consistent with numpy broadcasting, therefore a function written using arithmetic operations like <code>+</code>, <code>-</code>, <code>*</code>, or element-wise numpy functions (e.g. <code>numpy.maximum</code>, <code>np.sqrt</code>) would satisfy the requirement.</li> </ul>"},{"location":"specifications/snapper/","title":"Snapper","text":"<p>A Snapper represents a path dependent calculation, e.g. calculating returns in an equity cliquet. In the following timetable</p> <ul> <li>the first three events represent a snapper operation <code>addfix</code>. These operations store results in a snap.</li> <li>the last event represents a payment for the contract, which pays <code>ACC</code>, the value of the snap.</li> </ul> <pre><code>      time  op  quantity   unit track\n12/29/2023 NaN       0.0 addfix   NaN\n06/28/2024 NaN       0.0 addfix   NaN\n12/31/2024 NaN       0.0 addfix   NaN\n12/31/2024   +     100.0    ACC\n</code></pre> <p>A snapper is defined in the dataset, with four parameters. </p> <ul> <li>type, which must be \"snapper\"</li> <li>inp, a list of inputs to the snapper fn. These can be assets, such as \"SPX\", whose value comes from the model. These can also be snaps, such as \"ACC\" or \"S_last\", which has been stored as a result of previous snapper operation. </li> <li>fn, a python function that takes a list of inputs, and returns a list of outputs. The length of expected inputs list must match the length of inp, while the length of the output list must match the length of out.</li> <li>out, the list of name of snaps where the outputs are stored.  </li> </ul> <p>e.g. <pre><code># Define the function\ndef accumulator_update_fn(inputs):\n    [s, s_last, a] = inputs\n\n    ret = s / s_last - 1.0  # ret = S / S_last - 1\n    ret = np.maximum(local_floor, ret)\n    ret = np.minimum(local_cap, ret)\n\n    return [a + ret, s]  # [A, S_last]\n\n# Define the snapper\n\"CALCFIX\": {\n    \"type\": \"snapper\",\n    \"inp\": [\"SPX\", \"S_last\", \"ACC\"],\n    \"fn\": accumulator_update_fn,\n    \"out\": [\"ACC\", \"S_last\"],\n},\n</code></pre></p>"},{"location":"specifications/snapper/#function-signature","title":"Function Signature","text":"<p>See Phrase Function Signature</p>"},{"location":"specifications/timetable/","title":"Timetable","text":"<p>A contract is described by a list of events. An event has five properties -  time, op, quantity, unit, and track. Here is an example of an equity call option contract on SPX, with strike 2800 and one year expiration. It is described using three events.</p> <pre><code>            time   op  quantity unit track\n        03/31/2024  &gt;       0.0  USD\n        03/31/2024  +   -2900.0  USD\n        03/31/2024  +       1.0  SPX\n</code></pre>"},{"location":"specifications/timetable/#time","title":"Time","text":"<p>The UNIX timestamp (milliseconds) of an event. It can be specified as datetime and any of the methods of creating timetable below will convert it to the right format.</p>"},{"location":"specifications/timetable/#op","title":"Op","text":"<p>A string which can be <code>+</code>, <code>&gt;</code>, <code>&lt;</code>, or a condition. See more in Operations.</p>"},{"location":"specifications/timetable/#quantity","title":"Quantity","text":"<p>The quantity being paid (float).</p>"},{"location":"specifications/timetable/#unit","title":"Unit","text":"<p>A string that represents what is being paid. It can be a currency like <code>USD</code>, <code>EUR</code>, or a stock like <code>SPX</code>, <code>AAPL</code>, etc. See the Units section for all possible variants.</p>"},{"location":"specifications/timetable/#track","title":"Track","text":"<p>A string identifier for the contract, a leg of the contract, or a state of the contract. For simple contracts this might be just blank. See more in Tracks.</p>"},{"location":"specifications/timetable/#create-a-timetable","title":"Create a timetable","text":"<p>The timetable is a dictionary with two components.</p> <ul> <li>events: the sequence of events stored as a pyarrow recordbatch</li> <li>expressions (optional): a dictionary defining any phrases or snappers used in the timetable</li> </ul>"},{"location":"specifications/timetable/#create-using-from_pylist","title":"Create using <code>from_pylist</code>","text":"<p>A timetable can be created as follows, from a list of dicts. In this example we define a contract that pays 100 USD on 2024-12-31.</p> <pre><code>from pyarrow import RecordBatch as rb\nfrom datetime import datetime\nfrom qablet_contracts.timetable import TS_EVENT_SCHEMA\n\nevents = [\n    {\n        \"time\": datetime(2024, 12, 31),\n        \"op\": \"+\",\n        \"quantity\": 100.0,\n        \"unit\": \"USD\",\n        \"track\": \"\",\n    },\n]\ntimetable = {\n    \"events\": rb.from_pylist(events, schema=TS_EVENT_SCHEMA)\n}\n</code></pre>"},{"location":"specifications/timetable/#create-using-eventsmixin","title":"Create using <code>EventsMixin</code>","text":"<p>Alternatively, the same timetable as above can also be created using the <code>EventsMixin</code> class as shown below.</p> <pre><code>from qablet_contracts.timetable import EventsMixin\n\n@dataclass\nclass Bond(EventsMixin):\n    ccy: str\n    maturity: datetime\n    track: str = \"\"\n\n    def events(self):\n        return [\n            {\n                \"time\": self.maturity,\n                \"op\": \"+\",\n                \"quantity\": 1,\n                \"unit\": self.ccy,\n                \"track\": self.track,\n            }\n        ]\n\ntimetable = Bond(\"USD\", datetime(2024, 12, 31)).timetable()\n</code></pre>"},{"location":"specifications/timetable/#create-using-from_pandas","title":"Create using <code>from_pandas</code>","text":"<p>Here we create a timetable with two events using a pandas dataframe.</p> <pre><code>import pandas as pd\n\ndf = pd.DataFrame(\n    [\n        [datetime(2024, 6, 30), \"+\", 5.0, \"USD\", \"\"],\n        [datetime(2024, 12, 31), \"+\", 100.0, \"USD\", \"\"],\n    ],\n    columns=[\"time\", \"op\", \"quantity\", \"unit\", \"track\"],\n)\n\ntimetable = {\n    \"events\": rb.from_pandas(df, schema=TS_EVENT_SCHEMA),\n}\n</code></pre>"},{"location":"specifications/timetable/#print-a-timetable","title":"Print a timetable","text":"<p>The events of a timetable is a <code>pyarrow</code> recordbatch. It is an efficient data structure for storage, read, write and platform interoperabiity. However, it doesn't print pretty.</p>"},{"location":"specifications/timetable/#print-using-pandas","title":"Print using <code>pandas</code>","text":"<p>We can print by converting it to a pandas dataframe.</p> <pre><code>timetable[\"events\"].to_pandas()\n\n                       time op  quantity unit track\n0 2025-03-31 00:00:00+00:00  +       1.0  USD\n</code></pre>"},{"location":"specifications/timetable/#print-using-polars","title":"Print using <code>polars</code>","text":"<p>We can print by converting it to a polars dataframe.</p> <pre><code>from polars import from_arrow\ndf = from_arrow(timetable[\"events\"])\nprint(df)\n\nshape: (1, 5)\n\u250c-------------------------\u252c-----\u252c----------\u252c------\u252c-------\u2510\n\u2502 time                    \u2506 op  \u2506 quantity \u2506 unit \u2506 track \u2502\n\u2502 ---                     \u2506 --- \u2506 ---      \u2506 ---  \u2506 ---   \u2502\n\u2502 datetime[ms, UTC]       \u2506 cat \u2506 f64      \u2506 cat  \u2506 cat   \u2502\n\u255e-------------------------\u256a-----\u256a----------\u256a------\u256a-------\u2561\n\u2502 2025-03-31 00:00:00 UTC \u2506 +   \u2506 1.0      \u2506 USD  \u2506       \u2502\n\u2514-------------------------\u2534-----\u2534----------\u2534------\u2534-------\u2518\n</code></pre>"},{"location":"specifications/timetable/#print-using-print_events","title":"Print using <code>print_events</code>","text":"<p>The contract dataclass has a convenience function <code>print_events</code> to print a shorter form using pandas.</p> <pre><code>contract = Bond(\"USD\", datetime(2025, 3, 31))\ncontract.print_events()\n\n      time op  quantity unit track\n03/31/2025  +       1.0  USD\n</code></pre>"},{"location":"specifications/tracks/","title":"Tracks","text":"<p>A track identifies the contract, a leg of the contract, or a state of the contract. For simple contracts this might be just blank.</p> <pre><code>&gt;&gt;&gt; Option(\"USD\", \"SPX\", 2900, datetime(2024, 3, 31), True).print_events()\n\n      time op  quantity unit track\n03/31/2024  &gt;       0.0  USD\n03/31/2024  +   -2900.0  USD\n03/31/2024  +       1.0  SPX\n</code></pre> <p>Or you could assign a name to the track.</p> <pre><code>&gt;&gt;&gt; Option(\"USD\", \"SPX\", 2900, datetime(2024, 3, 31), True, track=\"&lt;SPX2900&gt;\").print_events()\n\n      time op  quantity unit     track\n03/31/2024  &gt;       0.0  USD &lt;SPX2900&gt;\n03/31/2024  +   -2900.0  USD &lt;SPX2900&gt;\n03/31/2024  +       1.0  SPX &lt;SPX2900&gt;\n</code></pre> <p>In this example there are two tracks - <code>.opt</code> and <code>.swp</code>. In the event <code>0</code> and <code>3</code> the holder has an opportunity to switch from the <code>.opt</code> track (which has no payments) to the <code>.swp</code> track (which has payments). See Bermuda Swaption for more on this example.</p> <pre><code>      time op  quantity unit track\n12/31/2023  &gt;     1.000 .swp  .opt\n12/31/2023  +     1.000  USD  .swp\n06/30/2024  +    -1.015  USD  .swp\n06/30/2024  &gt;     1.000 .swp  .opt\n06/30/2024  +     1.000  USD  .swp\n12/31/2024  +    -1.015  USD  .swp\n</code></pre>"},{"location":"specifications/units/","title":"Unit","text":"<p>A string representing what is being paid.</p>"},{"location":"specifications/units/#asset","title":"Asset","text":"<p>It can be a currency such as <code>USD</code>, <code>EUR</code>. e.g. in a Bond <pre><code>      time op  quantity unit track\n06/30/2024  +     0.025  USD\n</code></pre></p> <p>It can be a stock, index, or a commodity such as <code>SPX</code>, <code>AAPL</code>, <code>CL</code>. e.g. in a Vanilla Option <pre><code>      time op  quantity unit track\n03/31/2024  +       1.0  SPX\n</code></pre></p>"},{"location":"specifications/units/#track","title":"Track","text":"<p>In can represent a track, e.g. in a Bermuda Swaption this event indicates the choice to switch to the underlying swap (track <code>.swp</code>) instead of continuing on the current track (<code>.opt</code>) <pre><code>      time op  quantity unit track\n12/31/2023  &gt;     1.000 .swp  .opt\n</code></pre></p>"},{"location":"specifications/units/#phrase","title":"Phrase","text":"<p>such as a payoff formula in a Autocallable Note <pre><code>      time   op   quantity   unit track     \n07/31/2024    +   1.000000 payoff\n</code></pre></p>"},{"location":"specifications/units/#snap","title":"Snap","text":"<p>such as the accumulated returns in an accumulator cliquet. See more in the Snapper section. <pre><code>      time  op  quantity   unit track\n12/31/2024   +     100.0    ACC\n</code></pre></p>"},{"location":"specifications/units/#snapper","title":"Snapper","text":"<p>It can also represent an action, such as the snapper that updates an accumulator from the current return. <pre><code>      time  op  quantity   unit track\n06/30/2022 NaN       0.0 addfix   NaN\n</code></pre></p>"}]}