{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What is Qablet?","text":"<p>A Qablet timetable defines a financial product using a sequence of payments, choices and conditions. A valuation model implemented with a Qablet parser can value any contract, as long as the contract can be described using a Qablet Timetable such as this one -</p> <pre><code>          track        time op  quantity unit\n        0    #1  03/31/2024  &gt;       0.0  USD\n        1    #1  03/31/2024  +   -2900.0  USD\n        2    #1  03/31/2024  +       1.0  SPX\n</code></pre>"},{"location":"#overview-of-documentation","title":"Overview of Documentation","text":"<p>The SPECIFICATIONS section describes the various elements of the language. Start with the timetable.</p> <p>The CONTRACTS section documents this repository which contains classes to create qablet timetables for many common financial contracts such as Bonds, Options, Swaps, and Swaptions.</p>"},{"location":"#also-see","title":"Also See","text":"<p>The repo documented here does not contain models that price qablet timetables. Valuation and backtesting models are available in other independent projects, such as qablet-basic.</p> <ul> <li>Qablet Models documents the Monte-Carlo and Finite Difference models in qablet-basic.</li> <li>Qablet Learning Path is a set of Jupyter notebooks that value contracts using the qablet-basic package.</li> <li>Qablet Demo is an interactive experience.</li> </ul>"},{"location":"examples/bond_fixed/","title":"Fixed Bond","text":"<p>This module contains examples of fixed rate bonds.</p>"},{"location":"examples/bond_fixed/#qablet_contracts.bnd.fixed.FixedCashFlows","title":"<code>FixedCashFlows</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Contract</code></p> <p>A set of Fixed Cashflows in a single currency. This example also shows how to create a timetable from arrays instead of a list of dictionaries, which is more efficient.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of cashflows.</p> required <code>times</code> <p>a list or ndarray of cashflows times.</p> required <code>amounts</code> <code>List[float]</code> <p>a list ndarray of cashflows amounts.</p> required <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; times = [datetime(2023, 12, 31), datetime(2024, 6, 30), datetime(2024, 12, 31)]\n&gt;&gt;&gt; amounts = [0.05, 0.05, 1.05]\n&gt;&gt;&gt; FixedCashFlows(\"USD\", times, amounts).print_events()\n  track        time op  quantity unit\n0        12/31/2023  +      0.05  USD\n1        06/30/2024  +      0.05  USD\n2        12/31/2024  +      1.05  USD\n</code></pre> Source code in <code>qablet_contracts\\bnd\\fixed.py</code> <pre><code>@dataclass\nclass FixedCashFlows(Contract):\n    \"\"\"A set of **Fixed Cashflows** in a single currency. This example also shows how to create a timetable from arrays\n    instead of a list of dictionaries, which is more efficient.\n\n    Args:\n        ccy: the currency of cashflows.\n        times: a list or ndarray of cashflows times.\n        amounts: a list ndarray of cashflows amounts.\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; times = [datetime(2023, 12, 31), datetime(2024, 6, 30), datetime(2024, 12, 31)]\n        &gt;&gt;&gt; amounts = [0.05, 0.05, 1.05]\n        &gt;&gt;&gt; FixedCashFlows(\"USD\", times, amounts).print_events()\n          track        time op  quantity unit\n        0        12/31/2023  +      0.05  USD\n        1        06/30/2024  +      0.05  USD\n        2        12/31/2024  +      1.05  USD\n    \"\"\"\n\n    ccy: str\n    dates: List[datetime]\n    amounts: List[float]\n    track: str = \"\"\n\n    def timetable(self):\n        n = len(self.dates)\n        return {\n            \"events\": pa.RecordBatch.from_arrays(\n                [\n                    _const_dict_array(n, self.track),  # tracks\n                    pa.array(self.dates),\n                    _const_dict_array(n, \"+\"),  # ops\n                    pa.array(self.amounts),\n                    _const_dict_array(n, self.ccy),  # units\n                ],\n                schema=TS_EVENT_SCHEMA,\n            ),\n            \"expressions\": {},\n        }\n</code></pre>"},{"location":"examples/bond_fixed/#qablet_contracts.bnd.fixed.FixedBond","title":"<code>FixedBond</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Contract</code></p> <p>A Fixed Rate Bond pays a fixed rate at regular intervals, and the principal at maturity.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of cashflows.</p> required <code>coupon</code> <code>float</code> <p>the coupon rate per year.</p> required <code>maturity</code> <code>datetime</code> <p>the maturity of the bond.</p> required <code>freq</code> <code>str</code> <p>the number of coupon payments per year.</p> <code>'2BQE'</code> <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; FixedBond(\"USD\", 0.05, datetime(2023, 12, 31), datetime(2025, 12, 31), \"2QE\").print_events()\n  track        time op  quantity unit\n0        06/30/2024  +     0.025  USD\n1        12/31/2024  +     0.025  USD\n2        06/30/2025  +     0.025  USD\n3        12/31/2025  +     1.025  USD\n</code></pre> Source code in <code>qablet_contracts\\bnd\\fixed.py</code> <pre><code>@dataclass\nclass FixedBond(Contract):\n    \"\"\"A **Fixed Rate Bond** pays a fixed rate at regular intervals, and the principal at maturity.\n\n    Args:\n        ccy: the currency of cashflows.\n        coupon: the coupon rate per year.\n        maturity: the maturity of the bond.\n        freq: the number of coupon payments per year.\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; FixedBond(\"USD\", 0.05, datetime(2023, 12, 31), datetime(2025, 12, 31), \"2QE\").print_events()\n          track        time op  quantity unit\n        0        06/30/2024  +     0.025  USD\n        1        12/31/2024  +     0.025  USD\n        2        06/30/2025  +     0.025  USD\n        3        12/31/2025  +     1.025  USD\n    \"\"\"\n\n    ccy: str\n    coupon: float\n    accrual_start: datetime\n    maturity: datetime\n    freq: str = \"2BQE\"\n    track: str = \"\"\n\n    def timetable(self):\n        # Coupon period dates including the start of first period, and end of last period.\n        cpn_dates = pd.bdate_range(\n            self.accrual_start,\n            self.maturity,\n            freq=self.freq,\n            inclusive=\"both\",\n        )\n\n        amounts = [\n            dcf(end, start) * self.coupon\n            for start, end in zip(cpn_dates[:-1], cpn_dates[1:])\n        ]\n\n        amounts[-1] += 1  # The last payment includes the principal\n        return FixedCashFlows(\n            self.ccy, cpn_dates[1:], amounts, self.track\n        ).timetable()\n</code></pre>"},{"location":"examples/bond_zero/","title":"Zero Bond","text":"<p>This module contains examples of zero coupon bond and related contracts.</p>"},{"location":"examples/bond_zero/#qablet_contracts.bnd.zero.Bond","title":"<code>Bond</code>  <code>dataclass</code>","text":"<p>             Bases: <code>EventsMixin</code></p> <p>A zero coupon bond pays a single fixed payment at a future time.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the bond.</p> required <code>maturity</code> <code>datetime</code> <p>the maturity of the bond.</p> required <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Bond(\"USD\", datetime(2025, 3, 31)).print_events()\n  track        time op  quantity unit\n0        03/31/2025  +       1.0  USD\n</code></pre> Source code in <code>qablet_contracts\\bnd\\zero.py</code> <pre><code>@dataclass\nclass Bond(EventsMixin):\n    \"\"\"A **zero coupon bond** pays a single fixed payment at a future time.\n\n    Args:\n        ccy: the currency of the bond.\n        maturity: the maturity of the bond.\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; Bond(\"USD\", datetime(2025, 3, 31)).print_events()\n          track        time op  quantity unit\n        0        03/31/2025  +       1.0  USD\n    \"\"\"\n\n    ccy: str\n    maturity: datetime\n    track: str = \"\"\n\n    def events(self):\n        return [\n            {\n                \"track\": self.track,\n                \"time\": self.maturity,\n                \"op\": \"+\",\n                \"quantity\": 1,\n                \"unit\": self.ccy,\n            }\n        ]\n</code></pre>"},{"location":"examples/bond_zero/#qablet_contracts.bnd.zero.BondPut","title":"<code>BondPut</code>  <code>dataclass</code>","text":"<p>             Bases: <code>EventsMixin</code></p> <p>A zero coupon bond put offers the holder the option to sell a zero coupon bond for a fixed strike price, on the option maturity date.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the bond.</p> required <code>opt_maturity</code> <code>datetime</code> <p>the maturity of the option.</p> required <code>bond_maturity</code> <code>datetime</code> <p>the maturity of the bond.</p> required <code>strike</code> <code>float</code> <p>the option strike.</p> required <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; BondPut(\"USD\", datetime(2024, 9, 30), datetime(2025, 3, 31), 0.95).print_events()\n  track        time op  quantity unit\n0        09/30/2024  &gt;      0.00  USD\n1        09/30/2024  +      0.95  USD\n2        03/31/2025  +     -1.00  USD\n</code></pre> Source code in <code>qablet_contracts\\bnd\\zero.py</code> <pre><code>@dataclass\nclass BondPut(EventsMixin):\n    \"\"\"A **zero coupon bond put** offers the holder the option to sell a zero coupon bond for\n    a fixed strike price, on the option maturity date.\n\n    Args:\n        ccy: the currency of the bond.\n        opt_maturity: the maturity of the option.\n        bond_maturity: the maturity of the bond.\n        strike: the option strike.\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; BondPut(\"USD\", datetime(2024, 9, 30), datetime(2025, 3, 31), 0.95).print_events()\n          track        time op  quantity unit\n        0        09/30/2024  &gt;      0.00  USD\n        1        09/30/2024  +      0.95  USD\n        2        03/31/2025  +     -1.00  USD\n    \"\"\"\n\n    ccy: str\n    opt_maturity: datetime\n    bond_maturity: datetime\n    strike: float\n    track: str = \"\"\n\n    def events(self):\n        return [\n            {\n                \"track\": self.track,\n                \"time\": self.opt_maturity,\n                \"op\": \"&gt;\",\n                \"quantity\": 0,\n                \"unit\": self.ccy,\n            },  # Choose greater of nothing (get 0) or exercise (continue to remaining events)\n            {\n                \"track\": self.track,\n                \"time\": self.opt_maturity,\n                \"op\": \"+\",\n                \"quantity\": self.strike,\n                \"unit\": self.ccy,\n            },  # get strike at expiration\n            {\n                \"track\": self.track,\n                \"time\": self.bond_maturity,\n                \"op\": \"+\",\n                \"quantity\": -1,\n                \"unit\": self.ccy,\n            },  # pay bond notional at bond expiration\n        ]\n</code></pre>"},{"location":"examples/equity_autocall/","title":"AutoCallable Note","text":"<p>This module contains examples of autocallable notes.</p>"},{"location":"examples/equity_autocall/#qablet_contracts.eq.autocall.DiscountCert","title":"<code>DiscountCert</code>  <code>dataclass</code>","text":"<p>             Bases: <code>EventsMixin</code></p> <p>An Autocallable Discount Certificate is called if the asset price is above the barrier level on any of the barrier observation dates. If called, the note pays the principal and the coupon accreted till the call date. Otherwise, at maturity, if the asset is above strike, it pays the principal and the coupon at maturity. If the asset is below strike, the principal payment is scaled down proportionately with the asset price.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the option.</p> required <code>asset_name</code> <code>str</code> <p>the name of the underlying asset.</p> required <code>initial_spot</code> <code>float</code> <p>the initial spot price of the asset.</p> required <code>strike</code> <code>float</code> <p>downside participation below this strike.</p> required <code>maturity</code> <code>datetime</code> <p>the maturity of the option in years.</p> required <code>barrier</code> <code>float</code> <p>the note is called above this barrier level.</p> required <code>barrier_dates</code> <code>List[datetime]</code> <p>the barrier observation points.</p> required <code>cpn_rate</code> <code>float</code> <p>the coupon rate.</p> required <code>notional</code> <code>float</code> <p>the notional amount.</p> <code>100.0</code> <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; start = datetime(2024, 3, 31)\n&gt;&gt;&gt; maturity = datetime(2024, 7, 31)\n&gt;&gt;&gt; barrier_dates = pd.date_range(start, maturity, freq=\"ME\", inclusive=\"right\")\n&gt;&gt;&gt; DiscountCert(\"USD\", \"AAPL\", 100, 80, start, maturity, 102, barrier_dates, 0.092)print_events()\n  track        time    op    quantity    unit\n0        04/30/2024  CALL  100.836815     USD\n1        05/31/2024  CALL  101.680633     USD\n2        06/30/2024  CALL  102.531512     USD\n3        07/31/2024  CALL  103.389511     USD\n4        07/31/2024     +    1.000000  PAYOFF\n</code></pre> Source code in <code>qablet_contracts\\eq\\autocall.py</code> <pre><code>@dataclass\nclass DiscountCert(EventsMixin):\n    \"\"\"An **Autocallable Discount Certificate** is called if the asset price is above the barrier level\n    on any of the barrier observation dates. If called, the note pays the principal and the coupon accreted\n    till the call date. Otherwise, at maturity, if the asset is above strike, it pays the principal and the\n    coupon at maturity. If the asset is below strike, the principal payment is scaled down proportionately\n    with the asset price.\n\n    Args:\n        ccy: the currency of the option.\n        asset_name: the name of the underlying asset.\n        initial_spot: the initial spot price of the asset.\n        strike: downside participation below this strike.\n        maturity: the maturity of the option in years.\n        barrier: the note is called above this barrier level.\n        barrier_dates: the barrier observation points.\n        cpn_rate: the coupon rate.\n        notional: the notional amount.\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; start = datetime(2024, 3, 31)\n        &gt;&gt;&gt; maturity = datetime(2024, 7, 31)\n        &gt;&gt;&gt; barrier_dates = pd.date_range(start, maturity, freq=\"ME\", inclusive=\"right\")\n        &gt;&gt;&gt; DiscountCert(\"USD\", \"AAPL\", 100, 80, start, maturity, 102, barrier_dates, 0.092)print_events()\n          track        time    op    quantity    unit\n        0        04/30/2024  CALL  100.836815     USD\n        1        05/31/2024  CALL  101.680633     USD\n        2        06/30/2024  CALL  102.531512     USD\n        3        07/31/2024  CALL  103.389511     USD\n        4        07/31/2024     +    1.000000  PAYOFF\n    \"\"\"\n\n    ccy: str\n    asset_name: str\n    initial_spot: float\n    strike: float\n    accrual_start: datetime\n    maturity: datetime\n    barrier: float\n    barrier_dates: List[datetime]\n    cpn_rate: float\n    notional: float = 100.0\n    track: str = \"\"\n\n    def events(self):\n        events = []\n        # Autocall events\n        for barrier_date in self.barrier_dates:\n            # daycount_fraction\n            frac = dcf(barrier_date, self.accrual_start)\n            events.append(\n                {\n                    \"track\": self.track,\n                    \"time\": barrier_date,\n                    \"op\": \"CALL\",\n                    \"quantity\": self.notional * np.exp(frac * self.cpn_rate),\n                    \"unit\": self.ccy,\n                }\n            )\n\n        # payoff at maturity\n        events.append(\n            {\n                \"track\": \"\",\n                \"time\": self.maturity,\n                \"op\": \"+\",\n                \"quantity\": 1.0,\n                \"unit\": \"PAYOFF\",\n            }\n        )\n        return events\n\n    def fixed_payoff(self):\n        return self.notional * np.exp(\n            dcf(self.maturity, self.accrual_start) * self.cpn_rate\n        )\n\n    def expressions(self):\n        # Define the autocall condition\n        def ko_fn(inputs):\n            [S] = inputs\n            return [S &gt; (self.barrier * self.initial_spot / self.notional)]\n\n        call = {\n            \"type\": \"phrase\",\n            \"inp\": [self.asset_name],\n            \"fn\": ko_fn,\n        }\n\n        # Define the final payoff\n        def payoff_fn(inputs):\n            [s] = inputs\n            eq_pay = s * (self.notional / self.initial_spot)\n            return [\n                np.where(eq_pay &lt; self.strike, eq_pay, self.fixed_payoff())\n            ]\n\n        payoff = {\n            \"type\": \"phrase\",\n            \"inp\": [self.asset_name],\n            \"fn\": payoff_fn,\n        }\n\n        return {\"PAYOFF\": payoff, \"CALL\": call}\n</code></pre>"},{"location":"examples/equity_autocall/#qablet_contracts.eq.autocall.ReverseCB","title":"<code>ReverseCB</code>  <code>dataclass</code>","text":"<p>             Bases: <code>DiscountCert</code></p> <p>An Autocallable Reverse Convertible is called if the asset price is above the barrier level on any of the barrier observation dates. Otherwise, at maturity, if the asset is above strike, it pays the principal and the coupon at maturity. If the asset is below strike, the principal payment is scaled down proportionately with the asset price. The note pays periodic coupons until called or matured.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the option.</p> required <code>asset_name</code> <code>str</code> <p>the name of the underlying asset.</p> required <code>initial_spot</code> <code>float</code> <p>the initial spot price of the asset.</p> required <code>strike</code> <code>float</code> <p>downside participation below this strike.</p> required <code>maturity</code> <code>datetime</code> <p>the maturity of the option in years.</p> required <code>barrier</code> <code>float</code> <p>the note is called above this barrier level.</p> required <code>barrier_dates</code> <code>List[datetime]</code> <p>the barrier observation points.</p> required <code>cpn_rate</code> <code>float</code> <p>the coupon rate.</p> required <code>notional</code> <code>float</code> <p>the notional amount.</p> <code>100.0</code> <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; start = datetime(2024, 3, 31)\n&gt;&gt;&gt; maturity = datetime(2024, 7, 31)\n&gt;&gt;&gt; barrier_dates = pd.date_range(start, maturity, freq=\"ME\", inclusive=\"right\")\n&gt;&gt;&gt; ReverseCB(\"USD\", \"AAPL\", 100, 80, start, maturity, 102, barrier_dates, 0.10).print_events()\n  track        time    op    quantity    unit\n0        04/30/2024     +    0.833333     USD\n1        04/30/2024  CALL  100.000000     USD\n2        05/31/2024     +    0.833333     USD\n3        05/31/2024  CALL  100.000000     USD\n4        06/30/2024     +    0.833333     USD\n5        06/30/2024  CALL  100.000000     USD\n6        07/31/2024     +    0.833333     USD\n7        07/31/2024  CALL  100.000000     USD\n8        07/31/2024     +    1.000000  PAYOFF\n</code></pre> Source code in <code>qablet_contracts\\eq\\autocall.py</code> <pre><code>@dataclass\nclass ReverseCB(DiscountCert):\n    \"\"\"An **Autocallable Reverse Convertible** is called if the asset price is above the barrier level\n    on any of the barrier observation dates. Otherwise, at maturity, if the asset is above strike, it pays the principal and the\n    coupon at maturity. If the asset is below strike, the principal payment is scaled down proportionately\n    with the asset price. The note pays periodic coupons until called or matured.\n\n    Args:\n        ccy: the currency of the option.\n        asset_name: the name of the underlying asset.\n        initial_spot: the initial spot price of the asset.\n        strike: downside participation below this strike.\n        maturity: the maturity of the option in years.\n        barrier: the note is called above this barrier level.\n        barrier_dates: the barrier observation points.\n        cpn_rate: the coupon rate.\n        notional: the notional amount.\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; start = datetime(2024, 3, 31)\n        &gt;&gt;&gt; maturity = datetime(2024, 7, 31)\n        &gt;&gt;&gt; barrier_dates = pd.date_range(start, maturity, freq=\"ME\", inclusive=\"right\")\n        &gt;&gt;&gt; ReverseCB(\"USD\", \"AAPL\", 100, 80, start, maturity, 102, barrier_dates, 0.10).print_events()\n          track        time    op    quantity    unit\n        0        04/30/2024     +    0.833333     USD\n        1        04/30/2024  CALL  100.000000     USD\n        2        05/31/2024     +    0.833333     USD\n        3        05/31/2024  CALL  100.000000     USD\n        4        06/30/2024     +    0.833333     USD\n        5        06/30/2024  CALL  100.000000     USD\n        6        07/31/2024     +    0.833333     USD\n        7        07/31/2024  CALL  100.000000     USD\n        8        07/31/2024     +    1.000000  PAYOFF\n    \"\"\"\n\n    def events(self):\n        events = []\n        cpn_start_dates = [self.accrual_start] + list(self.barrier_dates[:-1])\n        # Autocall events\n        for start, end in zip(cpn_start_dates, self.barrier_dates):\n            # daycount_fraction\n            frac = dcf(end, start)\n            events.append(\n                {\n                    \"track\": self.track,\n                    \"time\": end,\n                    \"op\": \"+\",\n                    \"quantity\": self.notional * frac * self.cpn_rate,\n                    \"unit\": self.ccy,\n                }\n            )\n            events.append(\n                {\n                    \"track\": self.track,\n                    \"time\": end,\n                    \"op\": \"CALL\",\n                    \"quantity\": self.notional,\n                    \"unit\": self.ccy,\n                }\n            )\n\n        # payoff at maturity\n        events.append(\n            {\n                \"track\": \"\",\n                \"time\": self.maturity,\n                \"op\": \"+\",\n                \"quantity\": 1.0,\n                \"unit\": \"PAYOFF\",\n            }\n        )\n        return events\n\n    def fixed_payoff(self):\n        return self.notional\n</code></pre>"},{"location":"examples/equity_barrier/","title":"Barrier Option","text":"<p>This module contains examples of barrier options.</p>"},{"location":"examples/equity_barrier/#qablet_contracts.eq.barrier.OptionKO","title":"<code>OptionKO</code>  <code>dataclass</code>","text":"<p>             Bases: <code>EventsMixin</code></p> <p>In a Dn/Out Option the contract is cancelled if the underlying asset price falls below the barrier level on any of the barrier observation dates. In an Up/Out Option the contract is cancelled if the underlying asset price rises above the barrier level on any of the observation dates.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the option.</p> required <code>asset_name</code> <code>str</code> <p>the name of the underlying asset.</p> required <code>strike</code> <code>float</code> <p>the option strike.</p> required <code>maturity</code> <code>datetime</code> <p>the maturity of the option in years.</p> required <code>is_call</code> <code>bool</code> <p>true if the option is a call.</p> required <code>barrier</code> <code>float</code> <p>the barrier level.</p> required <code>barrier_type</code> <code>str</code> <p>the type of barrier option, e.g \"Dn/Out\" or \"Up/Out\".</p> required <code>barrier_dates</code> <code>List[datetime]</code> <p>the barrier observation points.</p> required <code>rebate</code> <code>float</code> <p>the rebate amount paid at cancellation.</p> <code>0</code> <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; start = datetime(2024, 3, 31)\n&gt;&gt;&gt; maturity = datetime(2024, 9, 30)\n&gt;&gt;&gt; barrier_dates = pd.date_range(start, maturity, freq=\"2ME\")\n&gt;&gt;&gt; OptionKO(\"USD\", \"EQ\", 100, maturity, True, 102, \"Up/Out\", barrier_dates).print_events()\n  track        time  op  quantity unit\n0        03/31/2024  KO       0.0  USD\n1        05/31/2024  KO       0.0  USD\n2        07/31/2024  KO       0.0  USD\n3        09/30/2024  KO       0.0  USD\n4        09/30/2024   &gt;       0.0  USD\n5        09/30/2024   +    -100.0  USD\n6        09/30/2024   +       1.0   EQ\n</code></pre> Source code in <code>qablet_contracts\\eq\\barrier.py</code> <pre><code>@dataclass\nclass OptionKO(EventsMixin):\n    \"\"\"In a **Dn/Out Option** the contract is cancelled if the underlying asset price\n    falls below the barrier level on any of the barrier observation dates.\n    In an **Up/Out Option** the contract is cancelled if the underlying asset price\n    rises above the barrier level on any of the observation dates.\n\n    Args:\n        ccy: the currency of the option.\n        asset_name: the name of the underlying asset.\n        strike: the option strike.\n        maturity: the maturity of the option in years.\n        is_call: true if the option is a call.\n        barrier: the barrier level.\n        barrier_type: the type of barrier option, e.g \"Dn/Out\" or \"Up/Out\".\n        barrier_dates: the barrier observation points.\n        rebate: the rebate amount paid at cancellation.\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; start = datetime(2024, 3, 31)\n        &gt;&gt;&gt; maturity = datetime(2024, 9, 30)\n        &gt;&gt;&gt; barrier_dates = pd.date_range(start, maturity, freq=\"2ME\")\n        &gt;&gt;&gt; OptionKO(\"USD\", \"EQ\", 100, maturity, True, 102, \"Up/Out\", barrier_dates).print_events()\n          track        time  op  quantity unit\n        0        03/31/2024  KO       0.0  USD\n        1        05/31/2024  KO       0.0  USD\n        2        07/31/2024  KO       0.0  USD\n        3        09/30/2024  KO       0.0  USD\n        4        09/30/2024   &gt;       0.0  USD\n        5        09/30/2024   +    -100.0  USD\n        6        09/30/2024   +       1.0   EQ\n    \"\"\"\n\n    ccy: str\n    asset_name: str\n    strike: float\n    maturity: datetime\n    is_call: bool\n    barrier: float\n    barrier_type: str\n    barrier_dates: List[datetime]\n    rebate: float = 0\n    track: str = \"\"\n\n    def events(self):\n        events = []\n        for barrier_date in self.barrier_dates:\n            events.append(\n                {\n                    \"track\": self.track,\n                    \"time\": barrier_date,\n                    \"op\": \"KO\",\n                    \"quantity\": self.rebate,\n                    \"unit\": self.ccy,\n                }\n            )\n\n        vanilla_events = Option(\n            self.ccy,\n            self.asset_name,\n            self.strike,\n            self.maturity,\n            self.is_call,\n            self.track,\n        ).events()\n\n        events.extend(vanilla_events)\n        return events\n\n    def expressions(self):\n        \"\"\"Define the knockout expression (KO).\"\"\"\n        if self.barrier_type == \"Dn/Out\":\n\n            def ko_fn(inputs):\n                [S] = inputs\n                return [S &lt; self.barrier]\n        elif self.barrier_type == \"Up/Out\":\n\n            def ko_fn(inputs):\n                [S] = inputs\n                return [S &gt; self.barrier]\n        else:\n            raise ValueError(f\"Unknown barrier type: {self.barrier_type}\")\n\n        return {\n            \"KO\": {\n                \"type\": \"phrase\",\n                \"inp\": [self.asset_name],\n                \"fn\": ko_fn,\n            }\n        }\n</code></pre>"},{"location":"examples/equity_barrier/#qablet_contracts.eq.barrier.OptionKO.expressions","title":"<code>expressions()</code>","text":"<p>Define the knockout expression (KO).</p> Source code in <code>qablet_contracts\\eq\\barrier.py</code> <pre><code>def expressions(self):\n    \"\"\"Define the knockout expression (KO).\"\"\"\n    if self.barrier_type == \"Dn/Out\":\n\n        def ko_fn(inputs):\n            [S] = inputs\n            return [S &lt; self.barrier]\n    elif self.barrier_type == \"Up/Out\":\n\n        def ko_fn(inputs):\n            [S] = inputs\n            return [S &gt; self.barrier]\n    else:\n        raise ValueError(f\"Unknown barrier type: {self.barrier_type}\")\n\n    return {\n        \"KO\": {\n            \"type\": \"phrase\",\n            \"inp\": [self.asset_name],\n            \"fn\": ko_fn,\n        }\n    }\n</code></pre>"},{"location":"examples/equity_cliquet/","title":"Cliquet","text":"<p>This module contains examples of equity cliquet contracts.</p> <p>In an Accumulator the payoff depends on the asset price on several fixing dates \\(T_0 &lt; T_1 &lt; ... T_N\\).</p> <p>If the returns are given by</p> \\[ r_i = \\frac{S_{T_{i+1}}-S_{T_i}}{S_{T_i}} \\] <p>Then contract has a single payoff at \\(T_N\\), given by</p> \\[ \\max \\left( floor_G, \\Sigma_0^{N-1} \\max(\\min(r_i, cap_L), floor_L) \\right) \\]"},{"location":"examples/equity_cliquet/#qablet_contracts.eq.cliquet.Accumulator","title":"<code>Accumulator</code>  <code>dataclass</code>","text":"<p>             Bases: <code>EventsMixin</code></p> <p>In an Accumulator the asset returns are calculated over a series of consecutive periods. Each return is subject to a local floor and cap, then accumulated by adding, and finally the accumulated payoff is subject to a global floor.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the bond.</p> required <code>asset_name</code> <code>str</code> <p>the name of the underlying asset.</p> required <code>fix_dates</code> <code>List[datetime]</code> <p>the fixing times of the cliquet.</p> required <code>global_floor</code> <code>float</code> <p>the global floor of the cliquet.</p> required <code>local_floor</code> <code>float</code> <p>the local floor of the cliquet.</p> required <code>local_cap</code> <code>float</code> <p>the local cap of the cliquet.</p> required <code>notional</code> <code>float</code> <p>the notional of the cliquet.</p> <code>100.0</code> <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fix_dates = pd.bdate_range(datetime(2021, 12, 31), datetime(2024, 12, 31), freq=\"2BQE\")\n&gt;&gt;&gt; Accumulator(\"USD\", \"SPX\", fix_dates, 0.0, -0.03, 0.05).print_events()\n  track        time   op  quantity     unit\n0   NaN  12/31/2021  NaN       0.0     INIT\n1   NaN  06/30/2022  NaN       0.0  CALCFIX\n2   NaN  12/30/2022  NaN       0.0  CALCFIX\n3   NaN  06/30/2023  NaN       0.0  CALCFIX\n4   NaN  12/29/2023  NaN       0.0  CALCFIX\n5   NaN  06/28/2024  NaN       0.0  CALCFIX\n6   NaN  12/31/2024  NaN       0.0  CALCFIX\n7        12/31/2024    &gt;       0.0      USD\n8        12/31/2024    +     100.0      ACC\n</code></pre> Source code in <code>qablet_contracts\\eq\\cliquet.py</code> <pre><code>@dataclass\nclass Accumulator(EventsMixin):\n    \"\"\"In an **Accumulator** the asset returns are calculated over a series of consecutive periods.\n    Each return is subject to a local floor and cap, then accumulated by adding, and finally the\n    accumulated payoff is subject to a global floor.\n\n    Args:\n        ccy: the currency of the bond.\n        asset_name: the name of the underlying asset.\n        fix_dates: the fixing times of the cliquet.\n        global_floor: the global floor of the cliquet.\n        local_floor: the local floor of the cliquet.\n        local_cap: the local cap of the cliquet.\n        notional: the notional of the cliquet.\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; fix_dates = pd.bdate_range(datetime(2021, 12, 31), datetime(2024, 12, 31), freq=\"2BQE\")\n        &gt;&gt;&gt; Accumulator(\"USD\", \"SPX\", fix_dates, 0.0, -0.03, 0.05).print_events()\n          track        time   op  quantity     unit\n        0   NaN  12/31/2021  NaN       0.0     INIT\n        1   NaN  06/30/2022  NaN       0.0  CALCFIX\n        2   NaN  12/30/2022  NaN       0.0  CALCFIX\n        3   NaN  06/30/2023  NaN       0.0  CALCFIX\n        4   NaN  12/29/2023  NaN       0.0  CALCFIX\n        5   NaN  06/28/2024  NaN       0.0  CALCFIX\n        6   NaN  12/31/2024  NaN       0.0  CALCFIX\n        7        12/31/2024    &gt;       0.0      USD\n        8        12/31/2024    +     100.0      ACC\n    \"\"\"\n\n    ccy: str\n    asset_name: str\n    fix_dates: List[datetime]\n    global_floor: float\n    local_floor: float\n    local_cap: float\n    notional: float = 100.0\n    track: str = \"\"\n    state: dict = field(default_factory=dict)\n\n    def events(self):\n        maturity = self.fix_dates[-1]\n\n        events = [\n            {\n                \"track\": None,\n                \"time\": self.fix_dates[0],\n                \"op\": None,\n                \"quantity\": 0,\n                \"unit\": \"INIT\",  # initialize accumulator\n            }\n        ]\n        for fixing_time in self.fix_dates[1:]:\n            events.append(\n                {\n                    \"track\": None,\n                    \"time\": fixing_time,\n                    \"op\": None,\n                    \"quantity\": 0,\n                    \"unit\": \"CALCFIX\",  # update accumulator\n                }\n            )\n        events.append(\n            {\n                \"track\": self.track,\n                \"time\": maturity,\n                \"op\": \"&gt;\",  # global floor\n                \"quantity\": self.global_floor,\n                \"unit\": self.ccy,\n            }\n        )\n        events.append(\n            {\n                \"track\": self.track,\n                \"time\": maturity,\n                \"op\": \"+\",  # pay the accumulated amount\n                \"quantity\": self.notional,\n                \"unit\": \"ACC\",\n            }\n        )\n        return events\n\n    def expressions(self):\n        last_acc = self.state.get(\"ACC\", 0.0)\n\n        if \"S_PREV\" in self.state:\n\n            def accumulator_init_fn(inputs):\n                [s] = inputs\n                return [last_acc, self.state[\"S_PREV\"]]  # [ACC, S_PREV]\n        else:\n\n            def accumulator_init_fn(inputs):\n                [s] = inputs\n                return [last_acc, s]  # [ACC, S_PREV]\n\n        def accumulator_update_fn(inputs):\n            [s, s_prev, a] = inputs\n\n            ret = s / s_prev - 1.0  # ret = S / S_PREV - 1\n            ret = np.maximum(self.local_floor, ret)\n            ret = np.minimum(self.local_cap, ret)\n\n            return [a + ret, s]  # [ACC, S_PREV]\n\n        return {\n            \"INIT\": {\n                \"type\": \"snapper\",\n                \"inp\": [self.asset_name],\n                \"fn\": accumulator_init_fn,\n                \"out\": [\"ACC\", \"S_PREV\"],\n            },\n            \"CALCFIX\": {\n                \"type\": \"snapper\",\n                \"inp\": [self.asset_name, \"S_PREV\", \"ACC\"],\n                \"fn\": accumulator_update_fn,\n                \"out\": [\"ACC\", \"S_PREV\"],\n            },\n        }\n</code></pre>"},{"location":"examples/equity_fwdoption/","title":"Forward Option","text":"<p>This module contains examples of forward starting options.</p>"},{"location":"examples/equity_fwdoption/#qablet_contracts.eq.forward.ForwardOption","title":"<code>ForwardOption</code>  <code>dataclass</code>","text":"<p>             Bases: <code>EventsMixin</code></p> <p>In a Forward Starting Option the strike price is set on a future date as a predetermine percent of the stock price on the strike fixing date.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the option.</p> required <code>asset_name</code> <code>str</code> <p>the name of the underlying asset.</p> required <code>strike_rate</code> <code>float</code> <p>the option strike in percent of fixing.</p> required <code>strike_date</code> <code>datetime</code> <p>the datetime at which the strike is fixed.</p> required <code>maturity</code> <code>datetime</code> <p>the maturity of the option in years.</p> required <code>is_call</code> <code>bool</code> <p>true if the option is a call.</p> required <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; timetable = ForwardOption( \"USD\", \"SPX\", 1.0,\ndatetime(2024, 3, 31), datetime(2024, 9, 30), True).print_events()\n  track        time   op  quantity    unit\n0   NaN  03/31/2024  NaN       0.0  .FIX_K\n1        09/30/2024    &gt;       0.0     USD\n2        09/30/2024    +      -1.0      .K\n3        09/30/2024    +       1.0     SPX\n</code></pre> Source code in <code>qablet_contracts\\eq\\forward.py</code> <pre><code>@dataclass\nclass ForwardOption(EventsMixin):\n    \"\"\"In a **Forward Starting Option** the strike price is set on a future date as\n    a predetermine percent of the stock price on the strike fixing date.\n\n    Args:\n        ccy: the currency of the option.\n        asset_name: the name of the underlying asset.\n        strike_rate: the option strike in percent of fixing.\n        strike_date: the datetime at which the strike is fixed.\n        maturity: the maturity of the option in years.\n        is_call: true if the option is a call.\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; timetable = ForwardOption( \"USD\", \"SPX\", 1.0,\n        datetime(2024, 3, 31), datetime(2024, 9, 30), True).print_events()\n          track        time   op  quantity    unit\n        0   NaN  03/31/2024  NaN       0.0  .FIX_K\n        1        09/30/2024    &gt;       0.0     USD\n        2        09/30/2024    +      -1.0      .K\n        3        09/30/2024    +       1.0     SPX\n    \"\"\"\n\n    ccy: str\n    asset_name: str\n    strike_rate: float\n    strike_date: datetime\n    maturity: datetime\n    is_call: bool\n    track: str = \"\"\n\n    def events(self):\n        sign = 1 if self.is_call else -1\n        return [\n            {\n                \"track\": None,\n                \"time\": self.strike_date,\n                \"op\": None,\n                \"quantity\": 0,\n                \"unit\": f\"{self.track}.FIX_K\",  # set the strike\n            },\n            {\n                \"track\": self.track,\n                \"time\": self.maturity,\n                \"op\": \"&gt;\",\n                \"quantity\": 0,\n                \"unit\": self.ccy,\n            },\n            {\n                \"track\": self.track,\n                \"time\": self.maturity,\n                \"op\": \"+\",\n                \"quantity\": -self.strike_rate * sign,\n                \"unit\": f\"{self.track}.K\",\n            },\n            {\n                \"track\": self.track,\n                \"time\": self.maturity,\n                \"op\": \"+\",\n                \"quantity\": sign,\n                \"unit\": self.asset_name,\n            },\n        ]\n\n    def expressions(self):\n        # Define the strike expression, return the spot itself.\n        def strike_fn(inputs):\n            return inputs\n\n        return {\n            f\"{self.track}.FIX_K\": {\n                \"type\": \"snapper\",\n                \"inp\": [self.asset_name],\n                \"fn\": strike_fn,\n                \"out\": [f\"{self.track}.K\"],\n            }\n        }\n</code></pre>"},{"location":"examples/equity_rainbow/","title":"Rainbow Option","text":"<p>This module contains examples of equity rainbow options.</p>"},{"location":"examples/equity_rainbow/#qablet_contracts.eq.rainbow.Rainbow","title":"<code>Rainbow</code>  <code>dataclass</code>","text":"<p>             Bases: <code>EventsMixin</code></p> <p>A Rainbow Call Option offers the holder the option to buy the best of a list of stocks (or none) for corresponding fixed strike prices, on the option maturity date. Similarly, a Rainbow Put Option offers the holder the option to sell the worst of a list of stocks (or none) for corresponding fixed strike prices.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the option.</p> required <code>asset_names</code> <code>List[str]</code> <p>the name of the underlying assets.</p> required <code>strikes</code> <code>List[float]</code> <p>the option strikes.</p> required <code>notional</code> <code>float</code> <p>the notional of the option.</p> required <code>maturity</code> <code>datetime</code> <p>the maturity of the option.</p> required <code>is_call</code> <code>bool</code> <p>true if the option is a call.</p> required <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assets = [\"SPX\", \"FTSE\", \"N225\"]\n&gt;&gt;&gt; strikes = [5087, 7684, 39100]\n&gt;&gt;&gt; Rainbow(\"USD\", assets, strikes, 100_000, datetime(2024, 3, 31), True).print_events()\n  track        time op       quantity  unit\n0        03/31/2024  + -100000.000000   USD\n1        03/31/2024  &gt;      19.657952   SPX\n2        03/31/2024  &gt;      13.014055  FTSE\n3        03/31/2024  &gt;       2.557545  N225\n4        03/31/2024  +  100000.000000   USD\n</code></pre> Source code in <code>qablet_contracts\\eq\\rainbow.py</code> <pre><code>@dataclass\nclass Rainbow(EventsMixin):\n    \"\"\"A **Rainbow Call Option** offers the holder the option to buy the best of\n    a list of stocks (or none) for corresponding fixed strike prices, on the option maturity date.\n    Similarly, a **Rainbow Put Option** offers the holder the option to sell the worst of\n    a list of stocks (or none) for corresponding fixed strike prices.\n\n    Args:\n        ccy: the currency of the option.\n        asset_names: the name of the underlying assets.\n        strikes: the option strikes.\n        notional: the notional of the option.\n        maturity: the maturity of the option.\n        is_call: true if the option is a call.\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; assets = [\"SPX\", \"FTSE\", \"N225\"]\n        &gt;&gt;&gt; strikes = [5087, 7684, 39100]\n        &gt;&gt;&gt; Rainbow(\"USD\", assets, strikes, 100_000, datetime(2024, 3, 31), True).print_events()\n          track        time op       quantity  unit\n        0        03/31/2024  + -100000.000000   USD\n        1        03/31/2024  &gt;      19.657952   SPX\n        2        03/31/2024  &gt;      13.014055  FTSE\n        3        03/31/2024  &gt;       2.557545  N225\n        4        03/31/2024  +  100000.000000   USD\n    \"\"\"\n\n    ccy: str\n    asset_names: List[str]\n    strikes: List[float]\n    notional: float\n    maturity: datetime\n    is_call: bool\n    track: str = \"\"\n\n    def events(self):\n        sign = 1 if self.is_call else -1\n        # Pay the initial strike\n        events = [\n            {\n                \"track\": \"\",\n                \"time\": self.maturity,\n                \"op\": \"+\",\n                \"quantity\": -self.notional * sign,\n                \"unit\": self.ccy,\n            },\n        ]\n\n        # Options to receive any of the assets\n        for asset, strike in zip(self.asset_names, self.strikes):\n            events.append(\n                {\n                    \"track\": \"\",\n                    \"time\": self.maturity,\n                    \"op\": \"&gt;\",\n                    \"quantity\": self.notional / strike * sign,\n                    \"unit\": asset,\n                }\n            )\n\n        # Otherwise receive the notional back\n        events.append(\n            {\n                \"track\": \"\",\n                \"time\": self.maturity,\n                \"op\": \"+\",\n                \"quantity\": self.notional * sign,\n                \"unit\": self.ccy,\n            }\n        )\n        return events\n</code></pre>"},{"location":"examples/equity_vanilla/","title":"Vanilla Option","text":"<p>This module contains examples of equity vanilla options.</p>"},{"location":"examples/equity_vanilla/#qablet_contracts.eq.vanilla.Option","title":"<code>Option</code>  <code>dataclass</code>","text":"<p>             Bases: <code>EventsMixin</code></p> <p>An European Call Option offers the holder the option to buy a stock for a fixed strike price, on the option maturity date. Similarly, a Put Option offers the holder the option to sell a stock for a fixed strike price.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the option.</p> required <code>asset_name</code> <code>str</code> <p>the name of the underlying asset.</p> required <code>strike</code> <code>float</code> <p>the option strike.</p> required <code>maturity</code> <code>datetime</code> <p>the maturity of the option.</p> required <code>is_call</code> <code>bool</code> <p>true if the option is a call.</p> required <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <p>Call:</p> <pre><code>&gt;&gt;&gt; Option(\"USD\", \"SPX\", 2900, datetime(2024, 3, 31), True, track=\"#1\").print_events()\n  track        time op  quantity unit\n0    #1  03/31/2024  &gt;       0.0  USD\n1    #1  03/31/2024  +   -2900.0  USD\n2    #1  03/31/2024  +       1.0  SPX\n</code></pre> <p>Put:</p> <pre><code>&gt;&gt;&gt; Option(\"USD\", \"SPX\", 2900, datetime(2024, 3, 31), False, track=\"#1\").print_events()\ntrack        time op  quantity unit\n0    #1  03/31/2024  &gt;       0.0  USD\n1    #1  03/31/2024  +    2900.0  USD\n2    #1  03/31/2024  +      -1.0  SPX\n</code></pre> Source code in <code>qablet_contracts\\eq\\vanilla.py</code> <pre><code>@dataclass\nclass Option(EventsMixin):\n    \"\"\"An **European Call Option** offers the holder the option to buy a stock for\n    a fixed strike price, on the option maturity date.\n    Similarly, a **Put Option** offers the holder the option to sell a stock for\n    a fixed strike price.\n\n    Args:\n        ccy: the currency of the option.\n        asset_name: the name of the underlying asset.\n        strike: the option strike.\n        maturity: the maturity of the option.\n        is_call: true if the option is a call.\n        track: an optional identifier for the contract.\n\n    Examples:\n        Call:\n        &gt;&gt;&gt; Option(\"USD\", \"SPX\", 2900, datetime(2024, 3, 31), True, track=\"#1\").print_events()\n          track        time op  quantity unit\n        0    #1  03/31/2024  &gt;       0.0  USD\n        1    #1  03/31/2024  +   -2900.0  USD\n        2    #1  03/31/2024  +       1.0  SPX\n\n        Put:\n        &gt;&gt;&gt; Option(\"USD\", \"SPX\", 2900, datetime(2024, 3, 31), False, track=\"#1\").print_events()\n        track        time op  quantity unit\n        0    #1  03/31/2024  &gt;       0.0  USD\n        1    #1  03/31/2024  +    2900.0  USD\n        2    #1  03/31/2024  +      -1.0  SPX\n    \"\"\"\n\n    ccy: str\n    asset_name: str\n    strike: float\n    maturity: datetime\n    is_call: bool\n    track: str = \"\"\n\n    def events(self):\n        sign = 1 if self.is_call else -1\n        return [\n            {\n                \"track\": self.track,\n                \"time\": self.maturity,\n                \"op\": \"&gt;\",\n                \"quantity\": 0,\n                \"unit\": self.ccy,\n            },\n            {\n                \"track\": self.track,\n                \"time\": self.maturity,\n                \"op\": \"+\",\n                \"quantity\": -self.strike * sign,\n                \"unit\": self.ccy,\n            },\n            {\n                \"track\": self.track,\n                \"time\": self.maturity,\n                \"op\": \"+\",\n                \"quantity\": sign,\n                \"unit\": self.asset_name,\n            },\n        ]\n</code></pre>"},{"location":"examples/rate_swap/","title":"Swaps","text":"<p>This module contains examples of interest rate swaps.</p>"},{"location":"examples/rate_swap/#qablet_contracts.ir.swap.Swap","title":"<code>Swap</code>  <code>dataclass</code>","text":"<p>             Bases: <code>EventsMixin</code></p> <p>In a Vanilla Swap, at the end of each period the holder pays a fixed rate and receives a floating rate. In this simple version the floating rate payment is replaced by receiving notional at the beginning of the period and paying the notional at the end of the period.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the swap.</p> required <code>dates</code> <code>List[datetime]</code> <p>the period datetimes of the swap, including the inception and maturity.</p> required <code>strike_rate</code> <code>float</code> <p>the strike rate of the swaption (in units, i.e. 0.02 means 200 bps).</p> required <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dates = pd.bdate_range(datetime(2023, 12, 31), datetime(2024, 12, 31), freq=\"2QE\")\n&gt;&gt;&gt; Swap(\"USD\", dates, strike_rate = 0.03).print_events()\n  track        time op  quantity unit\n0  .swp  12/31/2023  +     1.000  USD\n1  .swp  06/30/2024  +    -1.015  USD\n2  .swp  06/30/2024  +     1.000  USD\n3  .swp  12/31/2024  +    -1.015  USD\n</code></pre> Source code in <code>qablet_contracts\\ir\\swap.py</code> <pre><code>@dataclass\nclass Swap(EventsMixin):\n    \"\"\"In a **Vanilla Swap**, at the end of each period the holder pays a fixed rate and receives a floating rate.\n    In this simple version the floating rate payment is replaced by receiving notional at the beginning of the period\n    and paying the notional at the end of the period.\n\n    Args:\n        ccy: the currency of the swap.\n        dates: the period datetimes of the swap, including the inception and maturity.\n        strike_rate: the strike rate of the swaption (in units, i.e. 0.02 means 200 bps).\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; dates = pd.bdate_range(datetime(2023, 12, 31), datetime(2024, 12, 31), freq=\"2QE\")\n        &gt;&gt;&gt; Swap(\"USD\", dates, strike_rate = 0.03).print_events()\n          track        time op  quantity unit\n        0  .swp  12/31/2023  +     1.000  USD\n        1  .swp  06/30/2024  +    -1.015  USD\n        2  .swp  06/30/2024  +     1.000  USD\n        3  .swp  12/31/2024  +    -1.015  USD\n    \"\"\"\n\n    ccy: str\n    dates: List[datetime]\n    strike_rate: float\n    track: str = \"\"\n\n    def events(self):\n        events = []\n        # payment events\n        for start, end in zip(self.dates[0:-1], self.dates[1:]):\n            events.extend(\n                simple_swap_period(\n                    self.ccy, start, end, self.strike_rate, self.track + \".swp\"\n                )\n            )\n\n        return events\n</code></pre>"},{"location":"examples/rate_swap/#qablet_contracts.ir.swap.simple_swap_period","title":"<code>simple_swap_period(ccy, start, end, fixed_rate, track='')</code>","text":"<p>Simple representation of a swap period, paying fixed, receiving floating rate.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the swap.</p> required <code>start</code> <code>datetime</code> <p>the start of the period.</p> required <code>end</code> <code>datetime</code> <p>the end of the period.</p> required <code>fixed_rate</code> <code>float</code> <p>the fixed annual rate of the swap.</p> required <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> Source code in <code>qablet_contracts\\ir\\swap.py</code> <pre><code>def simple_swap_period(\n    ccy: str,\n    start: datetime,\n    end: datetime,\n    fixed_rate: float,\n    track: str = \"\",\n) -&gt; list:\n    \"\"\"Simple representation of a swap period, paying fixed, receiving floating rate.\n\n    Args:\n        ccy: the currency of the swap.\n        start: the start of the period.\n        end: the end of the period.\n        fixed_rate: the fixed annual rate of the swap.\n        track: an optional identifier for the contract.\n    \"\"\"\n    return [\n        {\n            \"track\": track,\n            \"time\": start,\n            \"op\": \"+\",\n            \"quantity\": 1,\n            \"unit\": ccy,\n        },\n        {\n            \"track\": track,\n            \"time\": end,\n            \"op\": \"+\",\n            \"quantity\": -1 - fixed_rate * dcf(end, start),\n            \"unit\": ccy,\n        },\n    ]\n</code></pre>"},{"location":"examples/rate_swaption/","title":"Swaptions","text":"<p>This module contains examples of interest rate swaptions.</p>"},{"location":"examples/rate_swaption/#qablet_contracts.ir.swaption.Swaption","title":"<code>Swaption</code>  <code>dataclass</code>","text":"<p>             Bases: <code>EventsMixin</code></p> <p>A Vanilla Swaption. In a Vanilla swaption the holder gets the opportunity to enter into the swap at the beginning of the first period.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the swap.</p> required <code>dates</code> <code>List[datetime]</code> <p>the period datetimes of the underlying swap, including the inception and maturity.</p> required <code>strike_rate</code> <code>float</code> <p>the strike rate of the swaption (in units, i.e. 0.02 means 200 bps).</p> required <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dates = pd.bdate_range(datetime(2023, 12, 31), datetime(2024, 12, 31), freq=\"2QE\")\n&gt;&gt;&gt; Swap(\"USD\", dates, strike_rate = 0.03).print_events()\n  track        time op  quantity  unit\n0  .opt  12/31/2023  &gt;     1.000  .swp\n1  .swp  12/31/2023  +     1.000   USD\n2  .swp  06/30/2024  +    -1.015   USD\n3  .swp  06/30/2024  +     1.000   USD\n4  .swp  12/31/2024  +    -1.015   USD\n</code></pre> Source code in <code>qablet_contracts\\ir\\swaption.py</code> <pre><code>@dataclass\nclass Swaption(EventsMixin):\n    \"\"\"A **Vanilla Swaption**.\n    In a Vanilla swaption the holder gets the opportunity to enter into the swap at the beginning of the first period.\n\n    Args:\n        ccy: the currency of the swap.\n        dates: the period datetimes of the underlying swap, including the inception and maturity.\n        strike_rate: the strike rate of the swaption (in units, i.e. 0.02 means 200 bps).\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; dates = pd.bdate_range(datetime(2023, 12, 31), datetime(2024, 12, 31), freq=\"2QE\")\n        &gt;&gt;&gt; Swap(\"USD\", dates, strike_rate = 0.03).print_events()\n          track        time op  quantity  unit\n        0  .opt  12/31/2023  &gt;     1.000  .swp\n        1  .swp  12/31/2023  +     1.000   USD\n        2  .swp  06/30/2024  +    -1.015   USD\n        3  .swp  06/30/2024  +     1.000   USD\n        4  .swp  12/31/2024  +    -1.015   USD\n    \"\"\"\n\n    ccy: str\n    dates: List[datetime]\n    strike_rate: float\n    track: str = \"\"\n\n    def events(self):\n        # option expiration event at beginning of the swap\n        events = [\n            {\n                \"track\": self.track + \".opt\",\n                \"time\": self.dates[0],\n                \"op\": \"&gt;\",\n                \"quantity\": 1,\n                \"unit\": self.track + \".swp\",\n            }\n        ]\n        # payment events for the underlying swap\n        for start, end in zip(self.dates[0:-1], self.dates[1:]):\n            events.extend(\n                simple_swap_period(\n                    self.ccy, start, end, self.strike_rate, self.track + \".swp\"\n                )\n            )\n\n        return events\n</code></pre>"},{"location":"examples/rate_swaption/#qablet_contracts.ir.swaption.BermudaSwaption","title":"<code>BermudaSwaption</code>  <code>dataclass</code>","text":"<p>             Bases: <code>EventsMixin</code></p> <p>In a Co-terminal Bermuda Swaption, the holder can exercise his option at the beginning of each swap period. If exercised, the holder pays and receives all remaining payments of the swap. If not exercised, there are no payments in the next swap period. Irrespective of the time of exercise, the swap terminates at the same date.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the swap.</p> required <code>dates</code> <code>List[datetime]</code> <p>the period datetimes of the underlying swap, including the inception and maturity.</p> required <code>strike_rate</code> <code>float</code> <p>the strike rate of the swaption (in units, i.e. 0.02 means 200 bps).</p> required <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dates = pd.bdate_range(datetime(2023, 12, 31), datetime(2024, 12, 31), freq=\"2QE\")\n&gt;&gt;&gt; Swap(\"USD\", dates, strike_rate = 0.03).print_events()\n  track        time op  quantity  unit\n0  .opt  12/31/2023  &gt;     1.000  .swp\n1  .swp  12/31/2023  +     1.000   USD\n2  .swp  06/30/2024  +    -1.015   USD\n3  .opt  06/30/2024  &gt;     1.000  .swp\n4  .swp  06/30/2024  +     1.000   USD\n5  .swp  12/31/2024  +    -1.015   USD\n</code></pre> Source code in <code>qablet_contracts\\ir\\swaption.py</code> <pre><code>@dataclass\nclass BermudaSwaption(EventsMixin):\n    \"\"\"In a **Co-terminal Bermuda Swaption**, the holder can exercise his option at the beginning of each swap period.\n    If exercised, the holder pays and receives all remaining payments of the swap. If not exercised, there are\n    no payments in the next swap period. Irrespective of the time of exercise, the swap terminates at the same date.\n\n    Args:\n        ccy: the currency of the swap.\n        dates: the period datetimes of the underlying swap, including the inception and maturity.\n        strike_rate: the strike rate of the swaption (in units, i.e. 0.02 means 200 bps).\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; dates = pd.bdate_range(datetime(2023, 12, 31), datetime(2024, 12, 31), freq=\"2QE\")\n        &gt;&gt;&gt; Swap(\"USD\", dates, strike_rate = 0.03).print_events()\n          track        time op  quantity  unit\n        0  .opt  12/31/2023  &gt;     1.000  .swp\n        1  .swp  12/31/2023  +     1.000   USD\n        2  .swp  06/30/2024  +    -1.015   USD\n        3  .opt  06/30/2024  &gt;     1.000  .swp\n        4  .swp  06/30/2024  +     1.000   USD\n        5  .swp  12/31/2024  +    -1.015   USD\n    \"\"\"\n\n    ccy: str\n    dates: List[datetime]\n    strike_rate: float\n    track: str = \"\"\n\n    def events(self):\n        events = []\n        for start, end in zip(self.dates[0:-1], self.dates[1:]):\n            # option expiration event before each period\n            events.append(\n                {\n                    \"track\": self.track + \".opt\",\n                    \"time\": start,\n                    \"op\": \"&gt;\",\n                    \"quantity\": 1,\n                    \"unit\": self.track + \".swp\",\n                }\n            )\n            # payment event for the underlying swap\n            events.extend(\n                simple_swap_period(\n                    self.ccy, start, end, self.strike_rate, self.track + \".swp\"\n                )\n            )\n\n        return events\n</code></pre>"},{"location":"specifications/batch/","title":"Batch","text":"<p>To be documented in a future revision.</p>"},{"location":"specifications/expressions/","title":"Expressions","text":"<p>The event table is often requires one or more of the following to capture the features of contract.</p> <ul> <li>A Phrase that represents a value calculated from one or more assets. e.g. calculating the barrier condition in a knock out option.</li> <li>A Snapper that represents a path dependent calculation, e.g. calculating returns in an equity cliquet.</li> <li>A Batch that represents a transition from a set of tracks to another set of tracks.</li> </ul>"},{"location":"specifications/operations/","title":"Operations","text":"<p>The op column contains a string which can be <code>+</code>, <code>&gt;</code>, <code>&lt;</code>, or a condition.</p>"},{"location":"specifications/operations/#payment","title":"Payment (+)","text":"<p><code>+</code> in the ops column indicates that the contract holder will receive the payment specified by the quantity and the unit, and then continue to receive whatever else is further down in the timetable in the same track.</p> <p>Example: A bond paying 5% semi-annually and maturing in two years. </p> <pre><code>  track        time op  quantity unit\n0        06/30/2024  +     0.025  USD\n1        12/31/2024  +     0.025  USD\n2        06/30/2025  +     0.025  USD\n3        12/31/2025  +     1.025  USD\n</code></pre>"},{"location":"specifications/operations/#choice-of-contract-holder","title":"Choice of contract holder (&gt;)","text":"<p><code>&gt;</code> in the ops column indicates that the contract holder can choose from the following two options</p> <ul> <li>receive the payment specified by the quantity and the unit, and then terminate the contract.</li> <li>or, instead of that payment, receive whatever else is further down in the timetable in the same track.</li> </ul> <p>Example: An European Call Option with strike 2900, expiring in 2024-03-31.</p> <pre><code>  track        time op  quantity unit\n0        03/31/2024  &gt;       0.0  USD\n1        03/31/2024  +   -2900.0  USD\n2        03/31/2024  +       1.0  SPX\n</code></pre> <p>Note</p> <p>A choice is different from a condition. In a choice, the holder of the contract (or counterparty) makes a decision. This decision takes future expectations into account, i.e. what is coming further down in the timetable. For the holder's choice, a reasonable model would choose the option with a greater expected value of future events.</p>"},{"location":"specifications/operations/#choice-of-counterparty","title":"Choice of counterparty (&lt;)","text":"<p><code>&lt;</code> in the ops column indicates that the counterparty can choose from the following two options</p> <ul> <li>pay the holder the payment specified by the quantity and the unit, and then terminate the contract.</li> <li>or, instead of that payment, pay the holder whatever else is further down in the timetable in the same track.</li> </ul> <p>Example: A callable bond, paying 5% USD semi-annually, maturing in two years, and callable at the end of the first year.</p> <pre><code>  track        time op  quantity unit\n0        06/30/2024  +     0.025  USD\n1        12/31/2024  +     0.025  USD\n2        12/31/2024  &lt;     1.000  USD\n3        06/30/2025  +     0.025  USD\n4        12/31/2025  +     1.025  USD\n</code></pre>"},{"location":"specifications/operations/#condition","title":"Condition","text":"<p>Any other string in the <code>op</code> column is assumed to be a phrase.</p> <ul> <li>If the phrase evaluates to true, the holder will receive the payment specified by the quantity and the unit, and then terminate the contract.</li> <li>If the phrase evaluates to false, then instead of that payment, holder will receive whatever else is further down in the timetable in the same track.</li> <li>If the phrase returns a float array instead of a bool array, the holder will receive a weighted sum of both outcomes.</li> </ul> <p>Example: knock-in or knock-out events in a barrier option. In the example below <code>KO</code> is a phrase that describes the barrier condition. If the condition is met the option is knocked out with a rebate of 1.0. If the barrier is not met, the contract continues further down the track.</p> <pre><code>          track        time  op  quantity unit\n        0        03/31/2024  KO       1.0  USD\n        1        05/31/2024  KO       1.0  USD\n        2        07/31/2024  KO       1.0  USD\n        3        09/30/2024  KO       1.0  USD\n        4        09/30/2024   &gt;       0.0  USD\n        5        09/30/2024   +    -100.0  USD\n        6        09/30/2024   +       1.0   EQ\n</code></pre> <p>See a complete example in Barrier Options.</p>"},{"location":"specifications/operations/#snapper","title":"Snapper","text":"<p>If the unit is a Snapper, i.e. a path dependent calculation to be performed at that time, then op should be <code>None</code> or <code>\"s\"</code>.</p>"},{"location":"specifications/phrase/","title":"Phrase","text":"<p>A Phrase represents a value calculated from one or more assets. e.g. calculating the barrier condition in a knock out option.</p> <p>A phrase is defined in the dataset, with three parameters.</p> <ul> <li>type, which must be \"phrase\"</li> <li>inp, a list of inputs to the phrase fn. An input can be an asset, such as \"SPX\", whose value comes from the model. It can also be a snap which has been stored as a result of previous snapper operation. It can also be another phrase.</li> <li>fn, a python function that takes a list of inputs, and returns a list of outputs. The length of expected inputs list must match the length of inp, while the length of the output list must be exactly one.</li> </ul> <p>e.g. <pre><code>def ko_fn(inputs):\n    [S] = inputs\n    return [S &lt; barrier]\n\n\"KO\": {\n    \"type\": \"phrase\",\n    \"inp\": [asset_name],\n    \"fn\": ko_fn,\n}\n</code></pre></p>"},{"location":"specifications/phrase/#function-signature","title":"Function Signature","text":"<p>The function should expect that inputs is a list of items. </p> <ul> <li>The length of the list will match the length of inp.</li> <li>Each item in the list can be a float, or a 1-D numpy array of size 1 or N (where N is the number of Monte-Carlo paths, or the length of the Finite Difference grid's asset-axis).</li> </ul> <p>The function should return a list of items.</p> <ul> <li>For a phrase the length of the output list must be exactly one, while for a snapper the length of the output list must match the lnegth of out.</li> <li>Each item inthe list should be a float, or a 1-D numpy array of size 1 or N. </li> </ul> <p>The item requirements are consistent with numpy broadcasting, therefore a function written using arithmetic operations like <code>+</code>, <code>-</code>, <code>*</code>, or element-wise numpy functions (e.g. <code>numpy.maximum</code>, <code>np.sqrt</code>) would satisfy these requirements.</p>"},{"location":"specifications/snapper/","title":"Snapper","text":"<p>A Snapper represents a path dependent calculation, e.g. calculating returns in an equity cliquet. In the following timetable</p> <ul> <li>the first three events represent a snapper operation <code>CALCFIX</code>. These operations store results in a snap.</li> <li>the last event represents a payment for the contract, which pays <code>ACC</code>, the value of the snap.</li> </ul> <pre><code>  track        time   op  quantity     unit\n4   NaN  12/29/2023  NaN       0.0  CALCFIX\n5   NaN  06/28/2024  NaN       0.0  CALCFIX\n6   NaN  12/31/2024  NaN       0.0  CALCFIX\n8        12/31/2024    +     100.0      ACC\n</code></pre> <p>A snapper is defined in the dataset, with four parameters. </p> <ul> <li>type, which must be \"snapper\"</li> <li>inp, a list of inputs to the snapper fn. These can be assets, such as \"SPX\", whose value comes from the model. These can also be snaps, such as \"ACC\" or \"S_last\", which has been stored as a result of previous snapper operation. </li> <li>fn, a python function that takes a list of inputs, and returns a list of outputs. The length of expected inputs list must match the length of inp, while the length of the output list must match the length of out.</li> <li>out, the list of name of snaps where the outputs are stored.  </li> </ul> <p>e.g. <pre><code># Define the function\ndef accumulator_update_fn(inputs):\n    [s, s_last, a] = inputs\n\n    ret = s / s_last - 1.0  # ret = S / S_last - 1\n    ret = np.maximum(local_floor, ret)\n    ret = np.minimum(local_cap, ret)\n\n    return [a + ret, s]  # [A, S_last]\n\n# Define the snapper\n\"CALCFIX\": {\n    \"type\": \"snapper\",\n    \"inp\": [\"SPX\", \"S_last\", \"ACC\"],\n    \"fn\": accumulator_update_fn,\n    \"out\": [\"ACC\", \"S_last\"],\n},\n</code></pre></p>"},{"location":"specifications/snapper/#function-signature","title":"Function Signature","text":"<p>See Phrase Function Signature</p>"},{"location":"specifications/timetable/","title":"Timetable","text":"<p>A contract is described by a list of events. An event has five properties -  track, time, op, quantity, and unit. Here is an example of an equity call option contract on SPX, with strike 2800 and one year expiration. It is described using three events.</p> <pre><code>  track        time op  quantity unit\n0    #1  03/31/2024  &gt;       0.0  USD\n1    #1  03/31/2024  +   -2900.0  USD\n2    #1  03/31/2024  +       1.0  SPX\n</code></pre>"},{"location":"specifications/timetable/#track","title":"Track","text":"<p>A string identifier for the contract, a leg of the contract, or a state of the contract. For simple contracts this might be just blank. See more in Tracks.</p>"},{"location":"specifications/timetable/#time","title":"Time","text":"<p>The UNIX timestamp (milliseconds) of an event.</p>"},{"location":"specifications/timetable/#op","title":"Op","text":"<p>A string which can be <code>+</code>, <code>&gt;</code>, <code>&lt;</code>, or a condition. See more in Operations.</p>"},{"location":"specifications/timetable/#quantity","title":"Quantity","text":"<p>The quantity being paid (float).</p>"},{"location":"specifications/timetable/#unit","title":"Unit","text":"<p>A string that represents what is being paid. It can be a currency like <code>USD</code>, <code>EUR</code>, or a stock like <code>SPX</code>, <code>AAPL</code>, etc. See the Units section for all possible variants.</p>"},{"location":"specifications/timetable/#create-a-timetable","title":"Create a timetable","text":"<p>The timetable is a dictionary with two components.</p> <ul> <li>events: the sequence of events stored as a pyarrow recordbatch</li> <li>expressions: a dictionary defining any phrases, snappers, or batches used in the timetable</li> </ul>"},{"location":"specifications/timetable/#create-using-from_pylist","title":"Create using <code>from_pylist</code>","text":"<p>A timetable can be created as follows, from a list of dicts. In this example we define a contract that pays 100 USD on 2024-12-31.</p> <pre><code>import pyarrow as pa\nfrom datetime import datetime\nfrom qablet_contracts.timetable import TS_EVENT_SCHEMA\n\nevents = [\n    {\n        \"track\": \"\",\n        \"time\": datetime(2024, 12, 31),\n        \"op\": \"+\",\n        \"quantity\": 100.0,\n        \"unit\": \"USD\",\n    },\n]\ntimetable = {\n    \"events\": pa.RecordBatch.from_pylist(events, schema=TS_EVENT_SCHEMA),\n    \"expressions\": {},\n}\n</code></pre>"},{"location":"specifications/timetable/#create-using-eventsmixin","title":"Create using <code>EventsMixin</code>","text":"<p>Alternatively, the same timetable as above can also be created using the <code>EventsMixin</code> class as shown below.</p> <pre><code>from qablet_contracts.timetable import EventsMixin\n\n@dataclass\nclass Bond(EventsMixin):\n    ccy: str\n    maturity: datetime\n    track: str = \"\"\n\n    def events(self):\n        return [\n            {\n                \"track\": self.track,\n                \"time\": self.maturity,\n                \"op\": \"+\",\n                \"quantity\": 1,\n                \"unit\": self.ccy,\n            }\n        ]\n\ntimetable = Bond(\"USD\", datetime(2024, 12, 31)).timetable()\n</code></pre>"},{"location":"specifications/timetable/#print-a-timetable","title":"Print a timetable","text":"<p>The events of a timetable is a <code>pyarrow</code> recordbatch. While it is an efficient data structure, it doesn't print pretty.</p>"},{"location":"specifications/timetable/#print-using-pandas","title":"Print using <code>pandas</code>","text":"<p>We can print by converting it to a pandas dataframe.</p> <pre><code>timetable[\"events\"].to_pandas()\n\n  track                      time op  quantity unit\n0       2025-03-31 00:00:00+00:00  +       1.0  USD\n</code></pre>"},{"location":"specifications/timetable/#print-using-polars","title":"Print using <code>polars</code>","text":"<p>We can print by converting it to a polars dataframe.</p> <pre><code>from polars import from_arrow\ndf = from_arrow(timetable[\"events\"])\nprint(df)\n\nshape: (1, 5)\n\u250c-------\u252c-------------------------\u252c-----\u252c----------\u252c------\u2510\n\u2502 track \u2506 time                    \u2506 op  \u2506 quantity \u2506 unit \u2502\n\u2502 ---   \u2506 ---                     \u2506 --- \u2506 ---      \u2506 ---  \u2502\n\u2502 cat   \u2506 datetime[ms, UTC]       \u2506 cat \u2506 f64      \u2506 cat  \u2502\n\u255e-------\u256a-------------------------\u256a-----\u256a----------\u256a------\u2561\n\u2502       \u2506 2025-03-31 00:00:00 UTC \u2506 +   \u2506 1.0      \u2506 USD  \u2502\n\u2514-------\u2534-------------------------\u2534-----\u2534----------\u2534------\u2518\n</code></pre>"},{"location":"specifications/timetable/#print-using-print_events","title":"Print using <code>print_events</code>","text":"<p>The contract dataclass has a convenience function <code>print_events</code> to print a shorter form using pandas.</p> <pre><code>contract = Bond(\"USD\", datetime(2025, 3, 31))\ncontract.print_events()\n\ntrack       time op  quantity unit\n      03/31/2025  +       1.0  USD\n</code></pre>"},{"location":"specifications/tracks/","title":"Tracks","text":"<p>A track identifies the contract, a leg of the contract, or a state of the contract. For simple contracts this might be just blank.</p> <pre><code>&gt;&gt;&gt; Option(\"USD\", \"SPX\", 2900, datetime(2024, 3, 31), True).print_events()\n\n  track        time op  quantity unit\n0        03/31/2024  &gt;       0.0  USD\n1        03/31/2024  +    2900.0  USD\n2        03/31/2024  +      -1.0  SPX\n</code></pre> <p>Or you could assign a name to the track.</p> <pre><code>&gt;&gt;&gt; Option(\"USD\", \"SPX\", 2900, datetime(2024, 3, 31), True, track=\"&lt;SPX2900&gt;\").print_events()\n\n       track        time op  quantity unit\n0  &lt;SPX2900&gt;  03/31/2024  &gt;       0.0  USD\n1  &lt;SPX2900&gt;  03/31/2024  +    2900.0  USD\n2  &lt;SPX2900&gt;  03/31/2024  +      -1.0  SPX\n</code></pre> <p>In this example there are two tracks - <code>.opt</code> and <code>.swp</code>. In the event <code>0</code> and <code>3</code> the holder has an opportunity to switch from the <code>.opt</code> track (which has no payments) to the <code>.swp</code> track (which has payments). See Bermuda Swaption for more on this example.</p> <pre><code>  track        time op  quantity  unit\n0  .opt  12/31/2023  &gt;     1.000  .swp\n1  .swp  12/31/2023  +     1.000   USD\n2  .swp  06/30/2024  +    -1.015   USD\n3  .opt  06/30/2024  &gt;     1.000  .swp\n4  .swp  06/30/2024  +     1.000   USD\n5  .swp  12/31/2024  +    -1.015   USD\n</code></pre>"},{"location":"specifications/units/","title":"Unit","text":"<p>A string representing what is being paid. It can be a </p> <ul> <li> <p>a currency like <code>USD</code>, <code>EUR</code>. e.g. in a Bond <pre><code>          track       time op  quantity unit\n                12/31/2023  +      0.05  USD\n</code></pre></p> </li> <li> <p>a stock, index, or a commodity, like <code>SPX</code>, <code>AAPL</code>, <code>CL</code>. e.g. in a Vanilla Option <pre><code>          track       time op  quantity unit\n                03/31/2024  +       1.0  SPX\n</code></pre></p> </li> <li> <p>a Track, e.g. the underlying swap in a Bermuda Swaption <pre><code>          track       time op  quantity unit\n          .opt  12/31/2023  &gt;    1.000  .swp\n</code></pre></p> </li> <li> <p>a Phrase, e.g. a libor fixing, or a digital payoff. e.g. see Autocallable Note <pre><code>          track       time op  quantity    unit\n                07/31/2024  +     1.000  PAYOFF\n</code></pre></p> </li> <li> <p>a Snap, i.e. a path dependent quantity, e.g. an accumulator cliquet. See more in the Snapper section. <pre><code>          track       time op  quantity   unit\n                12/31/2024  +    100.0     ACC\n</code></pre></p> </li> </ul> <p>It can also represent an action, such as</p> <ul> <li>a Snapper, e.g update an accumulator from the current return. <pre><code>          track       time   op  quantity     unit\n           NaN  06/30/2022  NaN       0.0  CALCFIX\n</code></pre></li> </ul>"}]}