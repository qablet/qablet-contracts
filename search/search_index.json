{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#what-is-qablet","title":"What is Qablet?","text":"<p>A Qablet timetable defines a financial product using a sequence of payments, choices and conditions. A valuation model implemented with a Qablet parser can value any contract, as long as the contract can be described using a Qablet Timetable.</p> <p>The repository documented here contains code to create qablet timetables. It does not contain models that price qablet timetables.  Valuation models are available in other independent projects.</p>"},{"location":"#overview-of-documentation","title":"Overview of Documentation","text":"<p>The SPECIFICATIONS section describes the various elements of the language. Start with the timetable.</p> <p>The CONTRACTS section has methods to create many common financial contracts such as bonds, options, swaps, and swaptions. Start with the Bonds.</p>"},{"location":"#valuation-models","title":"Valuation models","text":"<p>Valuation models are available in other independent projects, such as qablet-basic. See the Qablet Learning Path for a set of Jupyter notebooks that value contracts using Monte-Carlo and Finite Difference models from the qablet-basic package.</p>"},{"location":"examples/bond_fixed/","title":"Fixed Bond","text":"<p>This module contains examples of fixed rate bonds.</p>"},{"location":"examples/bond_fixed/#qablet_contracts.bnd.fixed.FixedCashFlows","title":"<code>FixedCashFlows</code>  <code>dataclass</code>","text":"<p>A set of Fixed Cashflows in a single currency. This example also shows how to create a timetable from arrays instead of a list of dictionaries, which is more efficient.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of cashflows.</p> required <code>times</code> <p>a list or ndarray of cashflows times.</p> required <code>amounts</code> <code>List[float]</code> <p>a list ndarray of cashflows amounts.</p> required <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tt = FixedCashFlows(\n    \"USD\",\n    [\n        datetime(2023, 12, 31),\n        datetime(2024, 6, 30),\n        datetime(2024, 12, 31),\n    ],\n    [0.05, 0.05, 1.05],\n).timetable()\n&gt;&gt;&gt; print(tt[\"events\"].to_pandas())\n  track                      time op  quantity unit\n0       2023-12-31 00:00:00+00:00  +      0.05  USD\n1       2024-06-30 00:00:00+00:00  +      0.05  USD\n2       2024-12-31 00:00:00+00:00  +      1.05  USD\n</code></pre> Source code in <code>qablet_contracts\\bnd\\fixed.py</code> <pre><code>@dataclass\nclass FixedCashFlows:\n    \"\"\"A set of **Fixed Cashflows** in a single currency. This example also shows how to create a timetable from arrays\n    instead of a list of dictionaries, which is more efficient.\n\n    Args:\n        ccy: the currency of cashflows.\n        times: a list or ndarray of cashflows times.\n        amounts: a list ndarray of cashflows amounts.\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; tt = FixedCashFlows(\n            \"USD\",\n            [\n                datetime(2023, 12, 31),\n                datetime(2024, 6, 30),\n                datetime(2024, 12, 31),\n            ],\n            [0.05, 0.05, 1.05],\n        ).timetable()\n        &gt;&gt;&gt; print(tt[\"events\"].to_pandas())\n          track                      time op  quantity unit\n        0       2023-12-31 00:00:00+00:00  +      0.05  USD\n        1       2024-06-30 00:00:00+00:00  +      0.05  USD\n        2       2024-12-31 00:00:00+00:00  +      1.05  USD\n    \"\"\"\n\n    ccy: str\n    dates: List[datetime]\n    amounts: List[float]\n    track: str = \"\"\n\n    def timetable(self):\n        n = len(self.dates)\n        return {\n            \"events\": pa.RecordBatch.from_arrays(\n                [\n                    _const_dict_array(n, self.track),  # tracks\n                    pa.array(self.dates),\n                    _const_dict_array(n, \"+\"),  # ops\n                    pa.array(self.amounts),\n                    _const_dict_array(n, self.ccy),  # units\n                ],\n                schema=TS_EVENT_SCHEMA,\n            ),\n            \"expressions\": {},\n        }\n</code></pre>"},{"location":"examples/bond_fixed/#qablet_contracts.bnd.fixed.FixedBond","title":"<code>FixedBond</code>  <code>dataclass</code>","text":"<p>A Fixed Rate Bond pays a fixed rate at regular intervals, and the principal at maturity.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of cashflows.</p> required <code>coupon</code> <code>float</code> <p>the coupon rate per year.</p> required <code>maturity</code> <code>datetime</code> <p>the maturity of the bond.</p> required <code>freq</code> <code>str</code> <p>the number of coupon payments per year.</p> <code>'2BQE'</code> <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tt = FixedBond(\n    \"USD\", 0.05, datetime(2023, 12, 31), datetime(2025, 12, 31), \"2QE\"\n).timetable()\n&gt;&gt;&gt; print(tt[\"events\"].to_pandas())\n  track                      time op  quantity unit\n0       2024-06-30 00:00:00+00:00  +     0.025  USD\n1       2024-12-31 00:00:00+00:00  +     0.025  USD\n2       2025-06-30 00:00:00+00:00  +     0.025  USD\n3       2025-12-31 00:00:00+00:00  +     1.025  USD\n</code></pre> Source code in <code>qablet_contracts\\bnd\\fixed.py</code> <pre><code>@dataclass\nclass FixedBond:\n    \"\"\"A **Fixed Rate Bond** pays a fixed rate at regular intervals, and the principal at maturity.\n\n    Args:\n        ccy: the currency of cashflows.\n        coupon: the coupon rate per year.\n        maturity: the maturity of the bond.\n        freq: the number of coupon payments per year.\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; tt = FixedBond(\n            \"USD\", 0.05, datetime(2023, 12, 31), datetime(2025, 12, 31), \"2QE\"\n        ).timetable()\n        &gt;&gt;&gt; print(tt[\"events\"].to_pandas())\n          track                      time op  quantity unit\n        0       2024-06-30 00:00:00+00:00  +     0.025  USD\n        1       2024-12-31 00:00:00+00:00  +     0.025  USD\n        2       2025-06-30 00:00:00+00:00  +     0.025  USD\n        3       2025-12-31 00:00:00+00:00  +     1.025  USD\n    \"\"\"\n\n    ccy: str\n    coupon: float\n    accrual_start: datetime\n    maturity: datetime\n    freq: str = \"2BQE\"\n    track: str = \"\"\n\n    def timetable(self):\n        # Coupon period dates including the start of first period, and end of last period.\n        cpn_dates = pd.bdate_range(\n            self.accrual_start,\n            self.maturity,\n            freq=self.freq,\n            inclusive=\"both\",\n        )\n\n        amounts = [\n            dcf(end, start) * self.coupon\n            for start, end in zip(cpn_dates[:-1], cpn_dates[1:])\n        ]\n\n        amounts[-1] += 1  # The last payment includes the principal\n        return FixedCashFlows(\n            self.ccy, cpn_dates[1:], amounts, self.track\n        ).timetable()\n</code></pre>"},{"location":"examples/bond_zero/","title":"Zero Bond","text":"<p>This module contains examples of zero coupon bond and related contracts.</p>"},{"location":"examples/bond_zero/#qablet_contracts.bnd.zero.Bond","title":"<code>Bond</code>  <code>dataclass</code>","text":"<p>             Bases: <code>EventsMixin</code></p> <p>A zero coupon bond pays a single fixed payment at a future time.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the bond.</p> required <code>maturity</code> <code>datetime</code> <p>the maturity of the bond.</p> required <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tt = Bond(\"USD\", datetime(2025, 3, 31)).timetable()\n&gt;&gt;&gt; print(tt[\"events\"].to_pandas())\n  track                      time op  quantity unit\n0       2025-03-31 00:00:00+00:00  +       1.0  USD\n</code></pre> Source code in <code>qablet_contracts\\bnd\\zero.py</code> <pre><code>@dataclass\nclass Bond(EventsMixin):\n    \"\"\"A **zero coupon bond** pays a single fixed payment at a future time.\n\n    Args:\n        ccy: the currency of the bond.\n        maturity: the maturity of the bond.\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; tt = Bond(\"USD\", datetime(2025, 3, 31)).timetable()\n        &gt;&gt;&gt; print(tt[\"events\"].to_pandas())\n          track                      time op  quantity unit\n        0       2025-03-31 00:00:00+00:00  +       1.0  USD\n    \"\"\"\n\n    ccy: str\n    maturity: datetime\n    track: str = \"\"\n\n    def events(self):\n        return [\n            {\n                \"track\": self.track,\n                \"time\": self.maturity,\n                \"op\": \"+\",\n                \"quantity\": 1,\n                \"unit\": self.ccy,\n            }\n        ]\n</code></pre>"},{"location":"examples/bond_zero/#qablet_contracts.bnd.zero.BondPut","title":"<code>BondPut</code>  <code>dataclass</code>","text":"<p>             Bases: <code>EventsMixin</code></p> <p>A zero coupon bond put offers the holder the option to sell a zero coupon bond for a fixed strike price, on the option maturity date.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the bond.</p> required <code>opt_maturity</code> <code>datetime</code> <p>the maturity of the option.</p> required <code>bond_maturity</code> <code>datetime</code> <p>the maturity of the bond.</p> required <code>strike</code> <code>float</code> <p>the option strike.</p> required <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tt = BondPut(\n    \"USD\", datetime(2024, 9, 30), datetime(2025, 3, 31), 0.95\n).timetable()\n&gt;&gt;&gt; print(tt[\"events\"].to_pandas())\n  track                      time op  quantity unit\n0       2024-09-30 00:00:00+00:00  &gt;      0.00  USD\n1       2024-09-30 00:00:00+00:00  +      0.95  USD\n2       2025-03-31 00:00:00+00:00  +     -1.00  USD\n</code></pre> Source code in <code>qablet_contracts\\bnd\\zero.py</code> <pre><code>@dataclass\nclass BondPut(EventsMixin):\n    \"\"\"A **zero coupon bond put** offers the holder the option to sell a zero coupon bond for\n    a fixed strike price, on the option maturity date.\n\n    Args:\n        ccy: the currency of the bond.\n        opt_maturity: the maturity of the option.\n        bond_maturity: the maturity of the bond.\n        strike: the option strike.\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; tt = BondPut(\n            \"USD\", datetime(2024, 9, 30), datetime(2025, 3, 31), 0.95\n        ).timetable()\n        &gt;&gt;&gt; print(tt[\"events\"].to_pandas())\n          track                      time op  quantity unit\n        0       2024-09-30 00:00:00+00:00  &gt;      0.00  USD\n        1       2024-09-30 00:00:00+00:00  +      0.95  USD\n        2       2025-03-31 00:00:00+00:00  +     -1.00  USD\n    \"\"\"\n\n    ccy: str\n    opt_maturity: datetime\n    bond_maturity: datetime\n    strike: float\n    track: str = \"\"\n\n    def events(self):\n        return [\n            {\n                \"track\": self.track,\n                \"time\": self.opt_maturity,\n                \"op\": \"&gt;\",\n                \"quantity\": 0,\n                \"unit\": self.ccy,\n            },  # Choose greater of nothing (get 0) or exercise (continue to remaining events)\n            {\n                \"track\": self.track,\n                \"time\": self.opt_maturity,\n                \"op\": \"+\",\n                \"quantity\": self.strike,\n                \"unit\": self.ccy,\n            },  # get strike at expiration\n            {\n                \"track\": self.track,\n                \"time\": self.bond_maturity,\n                \"op\": \"+\",\n                \"quantity\": -1,\n                \"unit\": self.ccy,\n            },  # pay bond notional at bond expiration\n        ]\n</code></pre>"},{"location":"examples/equity_autocall/","title":"AutoCallable Note","text":"<p>This module contains examples of autocallable notes.</p>"},{"location":"examples/equity_autocall/#qablet_contracts.eq.autocall.AutoCallable","title":"<code>AutoCallable</code>  <code>dataclass</code>","text":"<p>             Bases: <code>EventsMixin</code></p> <p>In an Autocallable Note the note is called if the asset price is above the barrier level on any of the barrier observation dates. On being called the note pays the principal and the coupon accreted till the call date. At maturity, if the note is not called by then,</p> <ul> <li>if the asset is above strike, it pays the principal and the coupon at maturity.</li> <li>if the asset is below strike, it pays the notional scaled down.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the option.</p> required <code>asset_name</code> <code>str</code> <p>the name of the underlying asset.</p> required <code>initial_spot</code> <code>float</code> <p>the initial spot price of the asset.</p> required <code>strike</code> <code>float</code> <p>downside participation below this strike.</p> required <code>maturity</code> <code>datetime</code> <p>the maturity of the option in years.</p> required <code>barrier</code> <code>float</code> <p>the note is called above this barrier level.</p> required <code>barrier_dates</code> <code>List[datetime]</code> <p>the barrier observation points.</p> required <code>cpn_rate</code> <code>float</code> <p>the coupon rate.</p> required <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; start = datetime(2024, 3, 31)\n&gt;&gt;&gt; maturity = datetime(2024, 9, 30)\n&gt;&gt;&gt; barrier_dates = pd.date_range(start, maturity, freq=\"ME\", inclusive=\"right\")\n&gt;&gt;&gt; tt = AutoCallable(\n    \"USD\", \"AAPL\", 100, 80, start, maturity, 102, barrier_dates, 0.092\n).timetable()\n&gt;&gt;&gt; print(tt[\"events\"].to_pandas())\n  track                      time    op    quantity    unit\n0       2024-04-30 00:00:00+00:00  CALL  100.769613     USD\n1       2024-05-31 00:00:00+00:00  CALL  101.545149     USD\n2       2024-06-30 00:00:00+00:00  CALL  102.326654     USD\n3       2024-07-31 00:00:00+00:00  CALL  103.114173     USD\n4       2024-08-31 00:00:00+00:00  CALL  103.907753     USD\n5       2024-09-30 00:00:00+00:00  CALL  104.707441     USD\n6       2024-09-30 00:00:00+00:00     +    1.000000  PAYOFF\n</code></pre> Source code in <code>qablet_contracts\\eq\\autocall.py</code> <pre><code>@dataclass\nclass AutoCallable(EventsMixin):\n    \"\"\"In an **Autocallable Note** the note is called if the asset price is above the barrier level\n    on any of the barrier observation dates. On being called the note pays the principal and the coupon accreted\n    till the call date. At maturity, if the note is not called by then,\n\n    - if the asset is above strike, it pays the principal and the coupon at maturity.\n    - if the asset is below strike, it pays the notional scaled down.\n\n    Args:\n        ccy: the currency of the option.\n        asset_name: the name of the underlying asset.\n        initial_spot: the initial spot price of the asset.\n        strike: downside participation below this strike.\n        maturity: the maturity of the option in years.\n        barrier: the note is called above this barrier level.\n        barrier_dates: the barrier observation points.\n        cpn_rate: the coupon rate.\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; start = datetime(2024, 3, 31)\n        &gt;&gt;&gt; maturity = datetime(2024, 9, 30)\n        &gt;&gt;&gt; barrier_dates = pd.date_range(start, maturity, freq=\"ME\", inclusive=\"right\")\n        &gt;&gt;&gt; tt = AutoCallable(\n            \"USD\", \"AAPL\", 100, 80, start, maturity, 102, barrier_dates, 0.092\n        ).timetable()\n        &gt;&gt;&gt; print(tt[\"events\"].to_pandas())\n          track                      time    op    quantity    unit\n        0       2024-04-30 00:00:00+00:00  CALL  100.769613     USD\n        1       2024-05-31 00:00:00+00:00  CALL  101.545149     USD\n        2       2024-06-30 00:00:00+00:00  CALL  102.326654     USD\n        3       2024-07-31 00:00:00+00:00  CALL  103.114173     USD\n        4       2024-08-31 00:00:00+00:00  CALL  103.907753     USD\n        5       2024-09-30 00:00:00+00:00  CALL  104.707441     USD\n        6       2024-09-30 00:00:00+00:00     +    1.000000  PAYOFF\n    \"\"\"\n\n    ccy: str\n    asset_name: str\n    initial_spot: float\n    strike: float\n    accrual_start: datetime\n    maturity: datetime\n    barrier: float\n    barrier_dates: List[datetime]\n    cpn_rate: float\n    track: str = \"\"\n\n    def events(self):\n        events = []\n        # Autocall events\n        for barrier_date in self.barrier_dates:\n            # daycount_fraction\n            frac = dcf(barrier_date, self.accrual_start)\n            events.append(\n                {\n                    \"track\": self.track,\n                    \"time\": barrier_date,\n                    \"op\": \"CALL\",\n                    \"quantity\": 100 * np.exp(frac * self.cpn_rate),\n                    \"unit\": self.ccy,\n                }\n            )\n\n        # payoff at maturity\n        events.append(\n            {\n                \"track\": \"\",\n                \"time\": self.maturity,\n                \"op\": \"+\",\n                \"quantity\": 1.0,\n                \"unit\": \"PAYOFF\",\n            }\n        )\n        return events\n\n    def expressions(self):\n        # Define the autocall condition\n        def ko_fn(inputs):\n            [S] = inputs\n            return [S &gt; (self.barrier * self.initial_spot / 100)]\n\n        call = {\n            \"type\": \"phrase\",\n            \"inp\": [self.asset_name],\n            \"fn\": ko_fn,\n        }\n\n        # Define the final payoff\n        fixed_pay = 100 * np.exp(\n            dcf(self.maturity, self.accrual_start) * self.cpn_rate\n        )\n\n        def payoff_fn(inputs):\n            [s] = inputs\n            eq_pay = s * (100 / self.initial_spot)\n            return [np.where(eq_pay &lt; self.strike, eq_pay, fixed_pay)]\n\n        payoff = {\n            \"type\": \"phrase\",\n            \"inp\": [self.asset_name],\n            \"fn\": payoff_fn,\n        }\n\n        return {\"PAYOFF\": payoff, \"CALL\": call}\n</code></pre>"},{"location":"examples/equity_barrier/","title":"Barrier Option","text":"<p>This module contains examples of barrier options.</p>"},{"location":"examples/equity_barrier/#qablet_contracts.eq.barrier.OptionKO","title":"<code>OptionKO</code>  <code>dataclass</code>","text":"<p>             Bases: <code>EventsMixin</code></p> <p>In a Dn/Out Option the contract is cancelled if the underlying asset price falls below the barrier level on any of the barrier observation dates. In an Up/Out Option the contract is cancelled if the underlying asset price rises above the barrier level on any of the observation dates.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the option.</p> required <code>asset_name</code> <code>str</code> <p>the name of the underlying asset.</p> required <code>strike</code> <code>float</code> <p>the option strike.</p> required <code>maturity</code> <code>datetime</code> <p>the maturity of the option in years.</p> required <code>is_call</code> <code>bool</code> <p>true if the option is a call.</p> required <code>barrier</code> <code>float</code> <p>the barrier level.</p> required <code>barrier_type</code> <code>str</code> <p>the type of barrier option, e.g \"Dn/Out\" or \"Up/Out\".</p> required <code>barrier_dates</code> <code>List[datetime]</code> <p>the barrier observation points.</p> required <code>rebate</code> <code>float</code> <p>the rebate amount paid at cancellation.</p> <code>0</code> <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; start = datetime(2024, 3, 31)\n&gt;&gt;&gt; maturity = datetime(2024, 9, 30)\n&gt;&gt;&gt; barrier_dates = pd.date_range(start, maturity, freq=\"2ME\")\n&gt;&gt;&gt; tt = OptionKO(\n    \"USD\", \"EQ\", 100, maturity, True, 102, \"Up/Out\", barrier_dates\n).timetable()\n&gt;&gt;&gt; print(tt[\"events\"].to_pandas())\n  track                      time  op  quantity unit\n0       2024-03-31 00:00:00+00:00  KO       0.0  USD\n1       2024-05-31 00:00:00+00:00  KO       0.0  USD\n2       2024-07-31 00:00:00+00:00  KO       0.0  USD\n3       2024-09-30 00:00:00+00:00  KO       0.0  USD\n4       2024-09-30 00:00:00+00:00   &gt;       0.0  USD\n5       2024-09-30 00:00:00+00:00   +    -100.0  USD\n6       2024-09-30 00:00:00+00:00   +       1.0   EQ\n</code></pre> Source code in <code>qablet_contracts\\eq\\barrier.py</code> <pre><code>@dataclass\nclass OptionKO(EventsMixin):\n    \"\"\"In a **Dn/Out Option** the contract is cancelled if the underlying asset price\n    falls below the barrier level on any of the barrier observation dates.\n    In an **Up/Out Option** the contract is cancelled if the underlying asset price\n    rises above the barrier level on any of the observation dates.\n\n    Args:\n        ccy: the currency of the option.\n        asset_name: the name of the underlying asset.\n        strike: the option strike.\n        maturity: the maturity of the option in years.\n        is_call: true if the option is a call.\n        barrier: the barrier level.\n        barrier_type: the type of barrier option, e.g \"Dn/Out\" or \"Up/Out\".\n        barrier_dates: the barrier observation points.\n        rebate: the rebate amount paid at cancellation.\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; start = datetime(2024, 3, 31)\n        &gt;&gt;&gt; maturity = datetime(2024, 9, 30)\n        &gt;&gt;&gt; barrier_dates = pd.date_range(start, maturity, freq=\"2ME\")\n        &gt;&gt;&gt; tt = OptionKO(\n            \"USD\", \"EQ\", 100, maturity, True, 102, \"Up/Out\", barrier_dates\n        ).timetable()\n        &gt;&gt;&gt; print(tt[\"events\"].to_pandas())\n          track                      time  op  quantity unit\n        0       2024-03-31 00:00:00+00:00  KO       0.0  USD\n        1       2024-05-31 00:00:00+00:00  KO       0.0  USD\n        2       2024-07-31 00:00:00+00:00  KO       0.0  USD\n        3       2024-09-30 00:00:00+00:00  KO       0.0  USD\n        4       2024-09-30 00:00:00+00:00   &gt;       0.0  USD\n        5       2024-09-30 00:00:00+00:00   +    -100.0  USD\n        6       2024-09-30 00:00:00+00:00   +       1.0   EQ\n    \"\"\"\n\n    ccy: str\n    asset_name: str\n    strike: float\n    maturity: datetime\n    is_call: bool\n    barrier: float\n    barrier_type: str\n    barrier_dates: List[datetime]\n    rebate: float = 0\n    track: str = \"\"\n\n    def events(self):\n        events = []\n        for barrier_date in self.barrier_dates:\n            events.append(\n                {\n                    \"track\": self.track,\n                    \"time\": barrier_date,\n                    \"op\": \"KO\",\n                    \"quantity\": self.rebate,\n                    \"unit\": self.ccy,\n                }\n            )\n\n        vanilla_events = Option(\n            self.ccy,\n            self.asset_name,\n            self.strike,\n            self.maturity,\n            self.is_call,\n            self.track,\n        ).events()\n\n        events.extend(vanilla_events)\n        return events\n\n    def expressions(self):\n        \"\"\"Define the knockout expression (KO).\"\"\"\n        if self.barrier_type == \"Dn/Out\":\n\n            def ko_fn(inputs):\n                [S] = inputs\n                return [S &lt; self.barrier]\n        elif self.barrier_type == \"Up/Out\":\n\n            def ko_fn(inputs):\n                [S] = inputs\n                return [S &gt; self.barrier]\n        else:\n            raise ValueError(f\"Unknown barrier type: {self.barrier_type}\")\n\n        return {\n            \"KO\": {\n                \"type\": \"phrase\",\n                \"inp\": [self.asset_name],\n                \"fn\": ko_fn,\n            }\n        }\n</code></pre>"},{"location":"examples/equity_barrier/#qablet_contracts.eq.barrier.OptionKO.expressions","title":"<code>expressions()</code>","text":"<p>Define the knockout expression (KO).</p> Source code in <code>qablet_contracts\\eq\\barrier.py</code> <pre><code>def expressions(self):\n    \"\"\"Define the knockout expression (KO).\"\"\"\n    if self.barrier_type == \"Dn/Out\":\n\n        def ko_fn(inputs):\n            [S] = inputs\n            return [S &lt; self.barrier]\n    elif self.barrier_type == \"Up/Out\":\n\n        def ko_fn(inputs):\n            [S] = inputs\n            return [S &gt; self.barrier]\n    else:\n        raise ValueError(f\"Unknown barrier type: {self.barrier_type}\")\n\n    return {\n        \"KO\": {\n            \"type\": \"phrase\",\n            \"inp\": [self.asset_name],\n            \"fn\": ko_fn,\n        }\n    }\n</code></pre>"},{"location":"examples/equity_cliquet/","title":"Cliquet","text":"<p>This module contains examples of equity cliquet contracts.</p> <p>In an Accumulator the payoff depends on the asset price on several fixing dates \\(T_0 &lt; T_1 &lt; ... T_N\\).</p> <p>If the returns are given by</p> \\[ r_i = \\frac{S_{T_{i+1}}-S_{T_i}}{S_{T_i}} \\] <p>Then contract has a single payoff at \\(T_N\\), given by</p> \\[ \\max \\left( floor_G, \\Sigma_0^{N-1} \\max(\\min(r_i, cap_L), floor_L) \\right) \\]"},{"location":"examples/equity_cliquet/#qablet_contracts.eq.cliquet.Accumulator","title":"<code>Accumulator</code>  <code>dataclass</code>","text":"<p>             Bases: <code>EventsMixin</code></p> <p>In an Accumulator the returns over consecutive periods are</p> <ul> <li>subject to a local floor and cap</li> <li>accumulated by adding</li> <li>the accumulated payoff is subject to a global floor</li> </ul> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the bond.</p> required <code>asset_name</code> <code>str</code> <p>the name of the underlying asset.</p> required <code>fix_dates</code> <code>List[datetime]</code> <p>the fixing times of the cliquet.</p> required <code>global_floor</code> <code>float</code> <p>the global floor of the cliquet.</p> required <code>local_floor</code> <code>float</code> <p>the local floor of the cliquet.</p> required <code>local_cap</code> <code>float</code> <p>the local cap of the cliquet.</p> required <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fix_dates = pd.bdate_range(datetime(2021, 12, 31), datetime(2024, 12, 31), freq=\"2BQE\")\n&gt;&gt;&gt; tt = Accumulator(\"USD\", \"SPX\", fix_dates, 0.0, -0.03, 0.05).timetable()\n&gt;&gt;&gt; print(tt[\"events\"].to_pandas())\n  track                      time   op  quantity     unit\n0   NaN 2021-12-31 00:00:00+00:00  NaN       0.0     INIT\n1   NaN 2022-06-30 00:00:00+00:00  NaN       0.0  CALCFIX\n2   NaN 2022-12-30 00:00:00+00:00  NaN       0.0  CALCFIX\n3   NaN 2023-06-30 00:00:00+00:00  NaN       0.0  CALCFIX\n4   NaN 2023-12-29 00:00:00+00:00  NaN       0.0  CALCFIX\n5   NaN 2024-06-28 00:00:00+00:00  NaN       0.0  CALCFIX\n6   NaN 2024-12-31 00:00:00+00:00  NaN       0.0  CALCFIX\n7       2024-12-31 00:00:00+00:00    &gt;       0.0      USD\n8       2024-12-31 00:00:00+00:00    +       1.0      ACC\n</code></pre> Source code in <code>qablet_contracts\\eq\\cliquet.py</code> <pre><code>@dataclass\nclass Accumulator(EventsMixin):\n    \"\"\"In an **Accumulator** the returns over consecutive periods are\n\n    - subject to a local floor and cap\n    - accumulated by adding\n    - the accumulated payoff is subject to a global floor\n\n    Args:\n        ccy: the currency of the bond.\n        asset_name: the name of the underlying asset.\n        fix_dates: the fixing times of the cliquet.\n        global_floor: the global floor of the cliquet.\n        local_floor: the local floor of the cliquet.\n        local_cap: the local cap of the cliquet.\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; fix_dates = pd.bdate_range(datetime(2021, 12, 31), datetime(2024, 12, 31), freq=\"2BQE\")\n        &gt;&gt;&gt; tt = Accumulator(\"USD\", \"SPX\", fix_dates, 0.0, -0.03, 0.05).timetable()\n        &gt;&gt;&gt; print(tt[\"events\"].to_pandas())\n          track                      time   op  quantity     unit\n        0   NaN 2021-12-31 00:00:00+00:00  NaN       0.0     INIT\n        1   NaN 2022-06-30 00:00:00+00:00  NaN       0.0  CALCFIX\n        2   NaN 2022-12-30 00:00:00+00:00  NaN       0.0  CALCFIX\n        3   NaN 2023-06-30 00:00:00+00:00  NaN       0.0  CALCFIX\n        4   NaN 2023-12-29 00:00:00+00:00  NaN       0.0  CALCFIX\n        5   NaN 2024-06-28 00:00:00+00:00  NaN       0.0  CALCFIX\n        6   NaN 2024-12-31 00:00:00+00:00  NaN       0.0  CALCFIX\n        7       2024-12-31 00:00:00+00:00    &gt;       0.0      USD\n        8       2024-12-31 00:00:00+00:00    +       1.0      ACC\n    \"\"\"\n\n    ccy: str\n    asset_name: str\n    fix_dates: List[datetime]\n    global_floor: float\n    local_floor: float\n    local_cap: float\n    track: str = \"\"\n    state: dict = field(default_factory=dict)\n\n    def events(self):\n        maturity = self.fix_dates[-1]\n\n        events = [\n            {\n                \"track\": None,\n                \"time\": self.fix_dates[0],\n                \"op\": None,\n                \"quantity\": 0,\n                \"unit\": \"INIT\",  # initialize accumulator\n            }\n        ]\n        for fixing_time in self.fix_dates[1:]:\n            events.append(\n                {\n                    \"track\": None,\n                    \"time\": fixing_time,\n                    \"op\": None,\n                    \"quantity\": 0,\n                    \"unit\": \"CALCFIX\",  # update accumulator\n                }\n            )\n        events.append(\n            {\n                \"track\": self.track,\n                \"time\": maturity,\n                \"op\": \"&gt;\",  # global floor\n                \"quantity\": self.global_floor,\n                \"unit\": self.ccy,\n            }\n        )\n        events.append(\n            {\n                \"track\": self.track,\n                \"time\": maturity,\n                \"op\": \"+\",  # pay the accumulated amount\n                \"quantity\": 1,\n                \"unit\": \"ACC\",\n            }\n        )\n        return events\n\n    def expressions(self):\n        last_acc = self.state.get(\"ACC\", 0.0)\n\n        if \"S_PREV\" in self.state:\n\n            def accumulator_init_fn(inputs):\n                [s] = inputs\n                return [last_acc, self.state[\"S_PREV\"]]  # [ACC, S_PREV]\n        else:\n\n            def accumulator_init_fn(inputs):\n                [s] = inputs\n                return [last_acc, s]  # [ACC, S_PREV]\n\n        def accumulator_update_fn(inputs):\n            [s, s_prev, a] = inputs\n\n            ret = s / s_prev - 1.0  # ret = S / S_PREV - 1\n            ret = np.maximum(self.local_floor, ret)\n            ret = np.minimum(self.local_cap, ret)\n\n            return [a + ret, s]  # [ACC, S_PREV]\n\n        return {\n            \"INIT\": {\n                \"type\": \"snapper\",\n                \"inp\": [self.asset_name],\n                \"fn\": accumulator_init_fn,\n                \"out\": [\"ACC\", \"S_PREV\"],\n            },\n            \"CALCFIX\": {\n                \"type\": \"snapper\",\n                \"inp\": [self.asset_name, \"S_PREV\", \"ACC\"],\n                \"fn\": accumulator_update_fn,\n                \"out\": [\"ACC\", \"S_PREV\"],\n            },\n        }\n</code></pre>"},{"location":"examples/equity_fwdoption/","title":"Forward Option","text":"<p>This module contains examples of forward starting options.</p>"},{"location":"examples/equity_fwdoption/#qablet_contracts.eq.forward.ForwardOption","title":"<code>ForwardOption</code>  <code>dataclass</code>","text":"<p>             Bases: <code>EventsMixin</code></p> <p>In a Forward Starting Option the strike price is set on a future date as a predetermine percent of the stock price on the strike fixing date.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the option.</p> required <code>asset_name</code> <code>str</code> <p>the name of the underlying asset.</p> required <code>strike_rate</code> <code>float</code> <p>the option strike in percent of fixing.</p> required <code>strike_date</code> <code>datetime</code> <p>the datetime at which the strike is fixed.</p> required <code>maturity</code> <code>datetime</code> <p>the maturity of the option in years.</p> required <code>is_call</code> <code>bool</code> <p>true if the option is a call.</p> required <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; timetable = ForwardOption( \"USD\", \"SPX\", 1.0,\ndatetime(2024, 3, 31), datetime(2024, 9, 30), True).timetable()\n&gt;&gt;&gt; print(timetable[\"events\"].to_pandas())\n  track                      time   op  quantity    unit\n0   NaN 2024-03-31 00:00:00+00:00  NaN       0.0  .FIX_K\n1       2024-09-30 00:00:00+00:00    &gt;       0.0     USD\n2       2024-09-30 00:00:00+00:00    +      -1.0      .K\n3       2024-09-30 00:00:00+00:00    +       1.0     SPX\n</code></pre> Source code in <code>qablet_contracts\\eq\\forward.py</code> <pre><code>@dataclass\nclass ForwardOption(EventsMixin):\n    \"\"\"In a **Forward Starting Option** the strike price is set on a future date as\n    a predetermine percent of the stock price on the strike fixing date.\n\n    Args:\n        ccy: the currency of the option.\n        asset_name: the name of the underlying asset.\n        strike_rate: the option strike in percent of fixing.\n        strike_date: the datetime at which the strike is fixed.\n        maturity: the maturity of the option in years.\n        is_call: true if the option is a call.\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; timetable = ForwardOption( \"USD\", \"SPX\", 1.0,\n        datetime(2024, 3, 31), datetime(2024, 9, 30), True).timetable()\n        &gt;&gt;&gt; print(timetable[\"events\"].to_pandas())\n          track                      time   op  quantity    unit\n        0   NaN 2024-03-31 00:00:00+00:00  NaN       0.0  .FIX_K\n        1       2024-09-30 00:00:00+00:00    &gt;       0.0     USD\n        2       2024-09-30 00:00:00+00:00    +      -1.0      .K\n        3       2024-09-30 00:00:00+00:00    +       1.0     SPX\n    \"\"\"\n\n    ccy: str\n    asset_name: str\n    strike_rate: float\n    strike_date: datetime\n    maturity: datetime\n    is_call: bool\n    track: str = \"\"\n\n    def events(self):\n        sign = 1 if self.is_call else -1\n        return [\n            {\n                \"track\": None,\n                \"time\": self.strike_date,\n                \"op\": None,\n                \"quantity\": 0,\n                \"unit\": f\"{self.track}.FIX_K\",  # set the strike\n            },\n            {\n                \"track\": self.track,\n                \"time\": self.maturity,\n                \"op\": \"&gt;\",\n                \"quantity\": 0,\n                \"unit\": self.ccy,\n            },\n            {\n                \"track\": self.track,\n                \"time\": self.maturity,\n                \"op\": \"+\",\n                \"quantity\": -self.strike_rate * sign,\n                \"unit\": f\"{self.track}.K\",\n            },\n            {\n                \"track\": self.track,\n                \"time\": self.maturity,\n                \"op\": \"+\",\n                \"quantity\": sign,\n                \"unit\": self.asset_name,\n            },\n        ]\n\n    def expressions(self):\n        # Define the strike expression, return the spot itself.\n        def strike_fn(inputs):\n            return inputs\n\n        return {\n            f\"{self.track}.FIX_K\": {\n                \"type\": \"snapper\",\n                \"inp\": [self.asset_name],\n                \"fn\": strike_fn,\n                \"out\": [f\"{self.track}.K\"],\n            }\n        }\n</code></pre>"},{"location":"examples/equity_rainbow/","title":"Rainbow Option","text":"<p>This module contains examples of equity rainbow options.</p>"},{"location":"examples/equity_rainbow/#qablet_contracts.eq.rainbow.Rainbow","title":"<code>Rainbow</code>  <code>dataclass</code>","text":"<p>             Bases: <code>EventsMixin</code></p> <p>A Rainbow Call Option offers the holder the option to buy the best of a list of stocks (or none) for corresponding fixed strike prices, on the option maturity date. Similarly, a Rainbow Put Option offers the holder the option to sell the worst of a list of stocks (or none) for corresponding fixed strike prices.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the option.</p> required <code>asset_names</code> <code>List[str]</code> <p>the name of the underlying assets.</p> required <code>strikes</code> <code>List[float]</code> <p>the option strikes.</p> required <code>notional</code> <code>float</code> <p>the notional of the option.</p> required <code>maturity</code> <code>datetime</code> <p>the maturity of the option.</p> required <code>is_call</code> <code>bool</code> <p>true if the option is a call.</p> required <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assets = [\"SPX\", \"FTSE\", \"N225\"]\n&gt;&gt;&gt; strikes = [5087, 7684, 39100]\n&gt;&gt;&gt; tt = Rainbow(\"USD\", assets, strikes, 100_000, datetime(2024, 3, 31), True).timetable()\n&gt;&gt;&gt; print(tt[\"events\"].to_pandas())\n  track                      time op       quantity  unit\n0       2024-03-31 00:00:00+00:00  + -100000.000000   USD\n1       2024-03-31 00:00:00+00:00  &gt;      19.657952   SPX\n2       2024-03-31 00:00:00+00:00  &gt;      13.014055  FTSE\n3       2024-03-31 00:00:00+00:00  &gt;       2.557545  N225\n4       2024-03-31 00:00:00+00:00  +  100000.000000   USD\n</code></pre> Source code in <code>qablet_contracts\\eq\\rainbow.py</code> <pre><code>@dataclass\nclass Rainbow(EventsMixin):\n    \"\"\"A **Rainbow Call Option** offers the holder the option to buy the best of\n    a list of stocks (or none) for corresponding fixed strike prices, on the option maturity date.\n    Similarly, a **Rainbow Put Option** offers the holder the option to sell the worst of\n    a list of stocks (or none) for corresponding fixed strike prices.\n\n    Args:\n        ccy: the currency of the option.\n        asset_names: the name of the underlying assets.\n        strikes: the option strikes.\n        notional: the notional of the option.\n        maturity: the maturity of the option.\n        is_call: true if the option is a call.\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; assets = [\"SPX\", \"FTSE\", \"N225\"]\n        &gt;&gt;&gt; strikes = [5087, 7684, 39100]\n        &gt;&gt;&gt; tt = Rainbow(\"USD\", assets, strikes, 100_000, datetime(2024, 3, 31), True).timetable()\n        &gt;&gt;&gt; print(tt[\"events\"].to_pandas())\n          track                      time op       quantity  unit\n        0       2024-03-31 00:00:00+00:00  + -100000.000000   USD\n        1       2024-03-31 00:00:00+00:00  &gt;      19.657952   SPX\n        2       2024-03-31 00:00:00+00:00  &gt;      13.014055  FTSE\n        3       2024-03-31 00:00:00+00:00  &gt;       2.557545  N225\n        4       2024-03-31 00:00:00+00:00  +  100000.000000   USD\n    \"\"\"\n\n    ccy: str\n    asset_names: List[str]\n    strikes: List[float]\n    notional: float\n    maturity: datetime\n    is_call: bool\n    track: str = \"\"\n\n    def events(self):\n        sign = 1 if self.is_call else -1\n        # Pay the initial strike\n        events = [\n            {\n                \"track\": \"\",\n                \"time\": self.maturity,\n                \"op\": \"+\",\n                \"quantity\": -self.notional * sign,\n                \"unit\": self.ccy,\n            },\n        ]\n\n        # Options to receive any of the assets\n        for asset, strike in zip(self.asset_names, self.strikes):\n            events.append(\n                {\n                    \"track\": \"\",\n                    \"time\": self.maturity,\n                    \"op\": \"&gt;\",\n                    \"quantity\": self.notional / strike * sign,\n                    \"unit\": asset,\n                }\n            )\n\n        # Otherwise receive the notional back\n        events.append(\n            {\n                \"track\": \"\",\n                \"time\": self.maturity,\n                \"op\": \"+\",\n                \"quantity\": self.notional * sign,\n                \"unit\": self.ccy,\n            }\n        )\n        return events\n</code></pre>"},{"location":"examples/equity_vanilla/","title":"Vanilla Option","text":"<p>This module contains examples of equity vanilla options.</p>"},{"location":"examples/equity_vanilla/#qablet_contracts.eq.vanilla.Option","title":"<code>Option</code>  <code>dataclass</code>","text":"<p>             Bases: <code>EventsMixin</code></p> <p>An European Call Option offers the holder the option to buy a stock for a fixed strike price, on the option maturity date. Similarly, a Put Option offers the holder the option to sell a stock for a fixed strike price.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the option.</p> required <code>asset_name</code> <code>str</code> <p>the name of the underlying asset.</p> required <code>strike</code> <code>float</code> <p>the option strike.</p> required <code>maturity</code> <code>datetime</code> <p>the maturity of the option.</p> required <code>is_call</code> <code>bool</code> <p>true if the option is a call.</p> required <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; call = Option(\"USD\", \"SPX\", 2900, datetime(2024, 3, 31), True, \"&lt;SPX2900&gt;\")\n&gt;&gt;&gt; call.timetable()[\"events\"].to_pandas()\n  track  time op  quantity  unit\n       track                      time op  quantity unit\n0  &lt;SPX2900&gt; 2024-03-31 00:00:00+00:00  &gt;       0.0  USD\n1  &lt;SPX2900&gt; 2024-03-31 00:00:00+00:00  +   -2900.0  USD\n2  &lt;SPX2900&gt; 2024-03-31 00:00:00+00:00  +       1.0  SPX\n</code></pre> <pre><code>&gt;&gt;&gt; put = Option(\"USD\", \"SPX\", 2900, datetime(2024, 3, 31), False, \"&lt;SPX2900&gt;\")\n&gt;&gt;&gt; put.timetable()[\"events\"].to_pandas()\n  track  time op  quantity  unit\n       track                      time op  quantity unit\n0  &lt;SPX2900&gt; 2024-03-31 00:00:00+00:00  &gt;       0.0  USD\n1  &lt;SPX2900&gt; 2024-03-31 00:00:00+00:00  +    2900.0  USD\n2  &lt;SPX2900&gt; 2024-03-31 00:00:00+00:00  +      -1.0  SPX\n</code></pre> Source code in <code>qablet_contracts\\eq\\vanilla.py</code> <pre><code>@dataclass\nclass Option(EventsMixin):\n    \"\"\"An **European Call Option** offers the holder the option to buy a stock for\n    a fixed strike price, on the option maturity date.\n    Similarly, a **Put Option** offers the holder the option to sell a stock for\n    a fixed strike price.\n\n    Args:\n        ccy: the currency of the option.\n        asset_name: the name of the underlying asset.\n        strike: the option strike.\n        maturity: the maturity of the option.\n        is_call: true if the option is a call.\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; call = Option(\"USD\", \"SPX\", 2900, datetime(2024, 3, 31), True, \"&lt;SPX2900&gt;\")\n        &gt;&gt;&gt; call.timetable()[\"events\"].to_pandas()\n          track  time op  quantity  unit\n               track                      time op  quantity unit\n        0  &lt;SPX2900&gt; 2024-03-31 00:00:00+00:00  &gt;       0.0  USD\n        1  &lt;SPX2900&gt; 2024-03-31 00:00:00+00:00  +   -2900.0  USD\n        2  &lt;SPX2900&gt; 2024-03-31 00:00:00+00:00  +       1.0  SPX\n\n        &gt;&gt;&gt; put = Option(\"USD\", \"SPX\", 2900, datetime(2024, 3, 31), False, \"&lt;SPX2900&gt;\")\n        &gt;&gt;&gt; put.timetable()[\"events\"].to_pandas()\n          track  time op  quantity  unit\n               track                      time op  quantity unit\n        0  &lt;SPX2900&gt; 2024-03-31 00:00:00+00:00  &gt;       0.0  USD\n        1  &lt;SPX2900&gt; 2024-03-31 00:00:00+00:00  +    2900.0  USD\n        2  &lt;SPX2900&gt; 2024-03-31 00:00:00+00:00  +      -1.0  SPX\n    \"\"\"\n\n    ccy: str\n    asset_name: str\n    strike: float\n    maturity: datetime\n    is_call: bool\n    track: str = \"\"\n\n    def events(self):\n        sign = 1 if self.is_call else -1\n        return [\n            {\n                \"track\": self.track,\n                \"time\": self.maturity,\n                \"op\": \"&gt;\",\n                \"quantity\": 0,\n                \"unit\": self.ccy,\n            },\n            {\n                \"track\": self.track,\n                \"time\": self.maturity,\n                \"op\": \"+\",\n                \"quantity\": -self.strike * sign,\n                \"unit\": self.ccy,\n            },\n            {\n                \"track\": self.track,\n                \"time\": self.maturity,\n                \"op\": \"+\",\n                \"quantity\": sign,\n                \"unit\": self.asset_name,\n            },\n        ]\n</code></pre>"},{"location":"examples/rate_swap/","title":"Swaps","text":"<p>This module contains examples of interest rate swaps.</p>"},{"location":"examples/rate_swap/#qablet_contracts.ir.swap.Swap","title":"<code>Swap</code>  <code>dataclass</code>","text":"<p>             Bases: <code>EventsMixin</code></p> <p>In a Vanilla Swap, at the end of each period the holder pays a fixed rate and receives a floating rate. In this simple version the floating rate payment is replaced by receiving notional at the beginning of the period and paying the notional at the end of the period.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the swap.</p> required <code>dates</code> <code>List[datetime]</code> <p>the period datetimes of the swap, including the inception and maturity.</p> required <code>strike_rate</code> <code>float</code> <p>the strike rate of the swaption (in units, i.e. 0.02 means 200 bps).</p> required <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dates = pd.bdate_range(datetime(2023, 12, 31), datetime(2024, 12, 31), freq=\"2QE\")\n&gt;&gt;&gt; tt = Swap(\"USD\", dates, strike_rate = 0.03).timetable()\n&gt;&gt;&gt; print(tt[\"events\"].to_pandas())\n  track                      time op  quantity unit\n0  .swp 2023-12-31 00:00:00+00:00  +     1.000  USD\n1  .swp 2024-06-30 00:00:00+00:00  +    -1.015  USD\n2  .swp 2024-06-30 00:00:00+00:00  +     1.000  USD\n3  .swp 2024-12-31 00:00:00+00:00  +    -1.015  USD\n</code></pre> Source code in <code>qablet_contracts\\ir\\swap.py</code> <pre><code>@dataclass\nclass Swap(EventsMixin):\n    \"\"\"In a **Vanilla Swap**, at the end of each period the holder pays a fixed rate and receives a floating rate.\n    In this simple version the floating rate payment is replaced by receiving notional at the beginning of the period\n    and paying the notional at the end of the period.\n\n    Args:\n        ccy: the currency of the swap.\n        dates: the period datetimes of the swap, including the inception and maturity.\n        strike_rate: the strike rate of the swaption (in units, i.e. 0.02 means 200 bps).\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; dates = pd.bdate_range(datetime(2023, 12, 31), datetime(2024, 12, 31), freq=\"2QE\")\n        &gt;&gt;&gt; tt = Swap(\"USD\", dates, strike_rate = 0.03).timetable()\n        &gt;&gt;&gt; print(tt[\"events\"].to_pandas())\n          track                      time op  quantity unit\n        0  .swp 2023-12-31 00:00:00+00:00  +     1.000  USD\n        1  .swp 2024-06-30 00:00:00+00:00  +    -1.015  USD\n        2  .swp 2024-06-30 00:00:00+00:00  +     1.000  USD\n        3  .swp 2024-12-31 00:00:00+00:00  +    -1.015  USD\n    \"\"\"\n\n    ccy: str\n    dates: List[datetime]\n    strike_rate: float\n    track: str = \"\"\n\n    def events(self):\n        events = []\n        # payment events\n        for start, end in zip(self.dates[0:-1], self.dates[1:]):\n            events.extend(\n                simple_swap_period(\n                    self.ccy, start, end, self.strike_rate, self.track + \".swp\"\n                )\n            )\n\n        return events\n</code></pre>"},{"location":"examples/rate_swap/#qablet_contracts.ir.swap.simple_swap_period","title":"<code>simple_swap_period(ccy, start, end, fixed_rate, track='')</code>","text":"<p>Simple representation of a swap period, paying fixed, receiving floating rate.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the swap.</p> required <code>start</code> <code>datetime</code> <p>the start of the period.</p> required <code>end</code> <code>datetime</code> <p>the end of the period.</p> required <code>fixed_rate</code> <code>float</code> <p>the fixed annual rate of the swap.</p> required <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> Source code in <code>qablet_contracts\\ir\\swap.py</code> <pre><code>def simple_swap_period(\n    ccy: str,\n    start: datetime,\n    end: datetime,\n    fixed_rate: float,\n    track: str = \"\",\n) -&gt; list:\n    \"\"\"Simple representation of a swap period, paying fixed, receiving floating rate.\n\n    Args:\n        ccy: the currency of the swap.\n        start: the start of the period.\n        end: the end of the period.\n        fixed_rate: the fixed annual rate of the swap.\n        track: an optional identifier for the contract.\n    \"\"\"\n    return [\n        {\n            \"track\": track,\n            \"time\": start,\n            \"op\": \"+\",\n            \"quantity\": 1,\n            \"unit\": ccy,\n        },\n        {\n            \"track\": track,\n            \"time\": end,\n            \"op\": \"+\",\n            \"quantity\": -1 - fixed_rate * dcf(end, start),\n            \"unit\": ccy,\n        },\n    ]\n</code></pre>"},{"location":"examples/rate_swaption/","title":"Swaptions","text":"<p>This module contains examples of interest rate swaptions.</p>"},{"location":"examples/rate_swaption/#qablet_contracts.ir.swaption.Swaption","title":"<code>Swaption</code>  <code>dataclass</code>","text":"<p>             Bases: <code>EventsMixin</code></p> <p>A Vanilla Swaption. In a Vanilla swaption the holder gets the opportunity to enter into the swap at the beginning of the first period.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the swap.</p> required <code>dates</code> <code>List[datetime]</code> <p>the period datetimes of the underlying swap, including the inception and maturity.</p> required <code>strike_rate</code> <code>float</code> <p>the strike rate of the swaption (in units, i.e. 0.02 means 200 bps).</p> required <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dates = pd.bdate_range(datetime(2023, 12, 31), datetime(2024, 12, 31), freq=\"2QE\")\n&gt;&gt;&gt; tt = Swap(\"USD\", dates, strike_rate = 0.03).timetable()\n&gt;&gt;&gt; print(tt[\"events\"].to_pandas())\n  track                      time op  quantity  unit\n0  .opt 2023-12-31 00:00:00+00:00  &gt;     1.000  .swp\n1  .swp 2023-12-31 00:00:00+00:00  +     1.000   USD\n2  .swp 2024-06-30 00:00:00+00:00  +    -1.015   USD\n3  .swp 2024-06-30 00:00:00+00:00  +     1.000   USD\n4  .swp 2024-12-31 00:00:00+00:00  +    -1.015   USD\n</code></pre> Source code in <code>qablet_contracts\\ir\\swaption.py</code> <pre><code>@dataclass\nclass Swaption(EventsMixin):\n    \"\"\"A **Vanilla Swaption**.\n    In a Vanilla swaption the holder gets the opportunity to enter into the swap at the beginning of the first period.\n\n    Args:\n        ccy: the currency of the swap.\n        dates: the period datetimes of the underlying swap, including the inception and maturity.\n        strike_rate: the strike rate of the swaption (in units, i.e. 0.02 means 200 bps).\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; dates = pd.bdate_range(datetime(2023, 12, 31), datetime(2024, 12, 31), freq=\"2QE\")\n        &gt;&gt;&gt; tt = Swap(\"USD\", dates, strike_rate = 0.03).timetable()\n        &gt;&gt;&gt; print(tt[\"events\"].to_pandas())\n          track                      time op  quantity  unit\n        0  .opt 2023-12-31 00:00:00+00:00  &gt;     1.000  .swp\n        1  .swp 2023-12-31 00:00:00+00:00  +     1.000   USD\n        2  .swp 2024-06-30 00:00:00+00:00  +    -1.015   USD\n        3  .swp 2024-06-30 00:00:00+00:00  +     1.000   USD\n        4  .swp 2024-12-31 00:00:00+00:00  +    -1.015   USD\n    \"\"\"\n\n    ccy: str\n    dates: List[datetime]\n    strike_rate: float\n    track: str = \"\"\n\n    def events(self):\n        # option expiration event at beginning of the swap\n        events = [\n            {\n                \"track\": self.track + \".opt\",\n                \"time\": self.dates[0],\n                \"op\": \"&gt;\",\n                \"quantity\": 1,\n                \"unit\": self.track + \".swp\",\n            }\n        ]\n        # payment events for the underlying swap\n        for start, end in zip(self.dates[0:-1], self.dates[1:]):\n            events.extend(\n                simple_swap_period(\n                    self.ccy, start, end, self.strike_rate, self.track + \".swp\"\n                )\n            )\n\n        return events\n</code></pre>"},{"location":"examples/rate_swaption/#qablet_contracts.ir.swaption.BermudaSwaption","title":"<code>BermudaSwaption</code>  <code>dataclass</code>","text":"<p>             Bases: <code>EventsMixin</code></p> <p>In a Co-terminal Bermuda Swaption, the holder can exercise his option at the beginning of each swap period. If exercised, the holder pays and receives all remaining payments of the swap. If not exercised, there are no payments in the next swap period. Irrespective of the time of exercise, the swap terminates at the same date.</p> <p>Parameters:</p> Name Type Description Default <code>ccy</code> <code>str</code> <p>the currency of the swap.</p> required <code>dates</code> <code>List[datetime]</code> <p>the period datetimes of the underlying swap, including the inception and maturity.</p> required <code>strike_rate</code> <code>float</code> <p>the strike rate of the swaption (in units, i.e. 0.02 means 200 bps).</p> required <code>track</code> <code>str</code> <p>an optional identifier for the contract.</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dates = pd.bdate_range(datetime(2023, 12, 31), datetime(2024, 12, 31), freq=\"2QE\")\n&gt;&gt;&gt; tt = Swap(\"USD\", dates, strike_rate = 0.03).timetable()\n&gt;&gt;&gt; print(tt[\"events\"].to_pandas())\n  track                      time op  quantity  unit\n0  .opt 2023-12-31 00:00:00+00:00  &gt;     1.000  .swp\n1  .swp 2023-12-31 00:00:00+00:00  +     1.000   USD\n2  .swp 2024-06-30 00:00:00+00:00  +    -1.015   USD\n3  .opt 2024-06-30 00:00:00+00:00  &gt;     1.000  .swp\n4  .swp 2024-06-30 00:00:00+00:00  +     1.000   USD\n5  .swp 2024-12-31 00:00:00+00:00  +    -1.015   USD\n</code></pre> Source code in <code>qablet_contracts\\ir\\swaption.py</code> <pre><code>@dataclass\nclass BermudaSwaption(EventsMixin):\n    \"\"\"In a **Co-terminal Bermuda Swaption**, the holder can exercise his option at the beginning of each swap period.\n    If exercised, the holder pays and receives all remaining payments of the swap. If not exercised, there are\n    no payments in the next swap period. Irrespective of the time of exercise, the swap terminates at the same date.\n\n    Args:\n        ccy: the currency of the swap.\n        dates: the period datetimes of the underlying swap, including the inception and maturity.\n        strike_rate: the strike rate of the swaption (in units, i.e. 0.02 means 200 bps).\n        track: an optional identifier for the contract.\n\n    Examples:\n        &gt;&gt;&gt; dates = pd.bdate_range(datetime(2023, 12, 31), datetime(2024, 12, 31), freq=\"2QE\")\n        &gt;&gt;&gt; tt = Swap(\"USD\", dates, strike_rate = 0.03).timetable()\n        &gt;&gt;&gt; print(tt[\"events\"].to_pandas())\n          track                      time op  quantity  unit\n        0  .opt 2023-12-31 00:00:00+00:00  &gt;     1.000  .swp\n        1  .swp 2023-12-31 00:00:00+00:00  +     1.000   USD\n        2  .swp 2024-06-30 00:00:00+00:00  +    -1.015   USD\n        3  .opt 2024-06-30 00:00:00+00:00  &gt;     1.000  .swp\n        4  .swp 2024-06-30 00:00:00+00:00  +     1.000   USD\n        5  .swp 2024-12-31 00:00:00+00:00  +    -1.015   USD\n    \"\"\"\n\n    ccy: str\n    dates: List[datetime]\n    strike_rate: float\n    track: str = \"\"\n\n    def events(self):\n        events = []\n        for start, end in zip(self.dates[0:-1], self.dates[1:]):\n            # option expiration event before each period\n            events.append(\n                {\n                    \"track\": self.track + \".opt\",\n                    \"time\": start,\n                    \"op\": \"&gt;\",\n                    \"quantity\": 1,\n                    \"unit\": self.track + \".swp\",\n                }\n            )\n            # payment event for the underlying swap\n            events.extend(\n                simple_swap_period(\n                    self.ccy, start, end, self.strike_rate, self.track + \".swp\"\n                )\n            )\n\n        return events\n</code></pre>"},{"location":"specifications/batch/","title":"Batch","text":"<p>To be documented in a future revision.</p>"},{"location":"specifications/expressions/","title":"Expressions","text":"<p>The event table is often requires one or more of the following to capture the features of contract.</p> <ul> <li>A Phrase that represents a value calculated from one or more assets. e.g. calculating the barrier condition in a knock out option.</li> <li>A Snapper that represents a path dependent calculation, e.g. calculating returns in an equity cliquet.</li> <li>A Batch that represents a transition from a set of tracks to another set of tracks.</li> </ul>"},{"location":"specifications/operations/","title":"Operations","text":"<p>The op column contains a string which can be <code>+</code>, <code>&gt;</code>, <code>&lt;</code>, or a condition.</p>"},{"location":"specifications/operations/#payment","title":"Payment (+)","text":"<p><code>+</code> in the ops column indicates that the contract holder will receive the payment specified by the quantity and the unit, and then continue to receive whatever else is further down in the timetable in the same track.</p> <p>Example: A bond paying 5% semi-annually and maturing in two years. </p> <pre><code>   track                      time op  quantity unit\n0       2024-06-30 00:00:00+00:00  +     0.025  USD\n1       2024-12-31 00:00:00+00:00  +     0.025  USD\n2       2025-06-30 00:00:00+00:00  +     0.025  USD\n3       2025-12-31 00:00:00+00:00  +     1.025  USD\n</code></pre>"},{"location":"specifications/operations/#choice-of-contract-holder","title":"Choice of contract holder (&gt;)","text":"<p><code>&gt;</code> in the ops column indicates that the contract holder can choose from the following two options</p> <ul> <li>receive the payment specified by the quantity and the unit, and then terminate the contract.</li> <li>or, instead of that payment, receive whatever else is further down in the timetable in the same track.</li> </ul> <p>Example: An European Call Option with strike 2900, expiring in 2024-03-31.</p> <pre><code>       track                      time op  quantity unit\n0  &lt;SPX2900&gt; 2024-03-31 00:00:00+00:00  &gt;       0.0  USD\n1  &lt;SPX2900&gt; 2024-03-31 00:00:00+00:00  +   -2900.0  USD\n2  &lt;SPX2900&gt; 2024-03-31 00:00:00+00:00  +       1.0  SPX\n</code></pre> <p>Note</p> <p>A choice is different from a condition. In a choice, the holder of the contract (or counterparty) makes a decision. This decision takes future expectations into account, i.e. what is coming further down in the timetable. For the holder's choice, a reasonable model would choose the option with a greater expected value of future events.</p>"},{"location":"specifications/operations/#choice-of-counterparty","title":"Choice of counterparty (&lt;)","text":"<p><code>&lt;</code> in the ops column indicates that the counterparty can choose from the following two options</p> <ul> <li>pay the holder the payment specified by the quantity and the unit, and then terminate the contract.</li> <li>or, instead of that payment, pay the holder whatever else is further down in the timetable in the same track.</li> </ul> <p>Example: A callable bond, paying 5% USD semi-annually, maturing in two years, and callable at the end of the first year.</p> <pre><code>   track                      time op  quantity unit\n0       2024-06-30 00:00:00+00:00  +     0.025  USD\n1       2024-12-31 00:00:00+00:00  +     0.025  USD\n1       2024-12-31 00:00:00+00:00  &lt;     1.000  USD\n2       2025-06-30 00:00:00+00:00  +     0.025  USD\n3       2025-12-31 00:00:00+00:00  +     1.025  USD\n</code></pre>"},{"location":"specifications/operations/#condition","title":"Condition","text":"<p>Any other string in the <code>op</code> column is assumed to be a phrase.</p> <ul> <li>If the phrase evaluates to true, the holder will receive the payment specified by the quantity and the unit, and then terminate the contract.</li> <li>If the phrase evaluates to false, then instead of that payment, holder will receive whatever else is further down in the timetable in the same track.</li> <li>If the phrase returns a float array instead of a bool array, the holder will receive a weighted sum of both outcomes.</li> </ul> <p>Example: knock-in or knock-out events in a barrier option. In the example below <code>KO</code> is a phrase that describes the barrier condition. If the condition is met the option is knocked out with a rebate of 1.0. If the barrier is not met, the contract continues further down the track.</p> <pre><code>  track                      time  op  quantity unit\n0       2024-03-31 00:00:00+00:00  KO       1.0  USD\n1       2024-05-31 00:00:00+00:00  KO       1.0  USD\n2       2024-07-31 00:00:00+00:00  KO       1.0  USD\n3       2024-09-30 00:00:00+00:00  KO       1.0  USD\n4       2024-09-30 00:00:00+00:00   &gt;       0.0  USD\n5       2024-09-30 00:00:00+00:00   +    -100.0  USD\n6       2024-09-30 00:00:00+00:00   +       1.0   EQ\n</code></pre> <p>See a complete example in Barrier Options.</p>"},{"location":"specifications/operations/#snapper","title":"Snapper","text":"<p>If the unit is a Snapper, i.e. a path dependent calculation to be performed at that time, then op should be <code>None</code> or <code>\"s\"</code>.</p>"},{"location":"specifications/phrase/","title":"Phrase","text":"<p>A Phrase represents a value calculated from one or more assets. e.g. calculating the barrier condition in a knock out option.</p> <p>A phrase is defined in the dataset, with three parameters.</p> <ul> <li>type, which must be \"phrase\"</li> <li>inp, a list of inputs to the phrase fn. An input can be an asset, such as \"SPX\", whose value comes from the model. It can also be a snap which has been stored as a result of previous snapper operation. It can also be another phrase.</li> <li>fn, a python function that takes a list of inputs, and returns a list of outputs. The length of expected inputs list must match the length of inp, while the length of the output list must be exactly one.</li> </ul> <p>e.g.</p> <pre><code>\ndef ko_fn(inputs):\n    [S] = inputs\n    return [S &lt; barrier]\n\n\"KO\": {\n    \"type\": \"phrase\",\n    \"inp\": [asset_name],\n    \"fn\": ko_fn,\n}\n\n</code></pre>"},{"location":"specifications/phrase/#function-signature","title":"Function Signature","text":"<p>The function should expect that inputs is a list of items. </p> <ul> <li>The length of the list will match the length of inp.</li> <li>Each item in the list can be a float, or a 1-D numpy array of size 1 or N (where N is the number of Monte-Carlo paths, or the length of the Finite Difference grid's asset-axis).</li> </ul> <p>The function should return a list of items.</p> <ul> <li>For a phrase the length of the output list must be exactly one, while for a snapper the length of the output list must match the lnegth of out.</li> <li>Each item inthe list should be a float, or a 1-D numpy array of size 1 or N. </li> </ul> <p>The item requirements are consistent with numpy broadcasting, therefore a function written using arithmetic operations like <code>+</code>, <code>-</code>, <code>*</code>, or element-wise numpy functions (e.g. <code>numpy.maximum</code>, <code>np.sqrt</code>) would satisfy these requirements.</p>"},{"location":"specifications/snapper/","title":"Snapper","text":"<p>A Snapper represents a path dependent calculation, e.g. calculating returns in an equity cliquet. In the following timetable</p> <ul> <li>the first three events represent a snapper operation <code>CALCFIX</code>. These operations store results in a snap.</li> <li>the last event represents a payment for the contract, which pays <code>ACC</code>, the value of the snap.</li> </ul> <pre><code> track                      time   op  quantity     unit\n   NaN 2023-12-29 00:00:00+00:00  NaN       0.0  CALCFIX\n   NaN 2024-06-28 00:00:00+00:00  NaN       0.0  CALCFIX\n   NaN 2024-12-31 00:00:00+00:00  NaN       0.0  CALCFIX\n       2024-12-31 00:00:00+00:00    +       1.0      ACC\n</code></pre> <p>A snapper is defined in the dataset, with four parameters. </p> <ul> <li>type, which must be \"snapper\"</li> <li>inp, a list of inputs to the snapper fn. These can be assets, such as \"SPX\", whose value comes from the model. These can also be snaps, such as \"ACC\" or \"S_last\", which has been stored as a result of previous snapper operation. </li> <li>fn, a python function that takes a list of inputs, and returns a list of outputs. The length of expected inputs list must match the length of inp, while the length of the output list must match the length of out.</li> <li>out, the list of name of snaps where the outputs are stored.  </li> </ul> <p>e.g.</p> <pre><code># Define the function\ndef accumulator_update_fn(inputs):\n    [s, s_last, a] = inputs\n\n    ret = s / s_last - 1.0  # ret = S / S_last - 1\n    ret = np.maximum(local_floor, ret)\n    ret = np.minimum(local_cap, ret)\n\n    return [a + ret, s]  # [A, S_last]\n\n# Define the snapper\n\"CALCFIX\": {\n    \"type\": \"snapper\",\n    \"inp\": [\"SPX\", \"S_last\", \"ACC\"],\n    \"fn\": accumulator_update_fn,\n    \"out\": [\"ACC\", \"S_last\"],\n},\n</code></pre>"},{"location":"specifications/snapper/#function-signature","title":"Function Signature","text":"<p>See Phrase Function Signature</p>"},{"location":"specifications/timetable/","title":"Timetable","text":"<p>A contract is described by a list of events. An event has five properties -  track, time, op, quantity, and unit. Here is an example of an equity call option contract on SPX, with strike 2800 and one year expiration. It is described using three events.</p> <pre><code>       track                      time op  quantity unit\n0  &lt;SPX2900&gt; 2024-03-31 00:00:00+00:00  &gt;       0.0  USD\n1  &lt;SPX2900&gt; 2024-03-31 00:00:00+00:00  +    2900.0  USD\n2  &lt;SPX2900&gt; 2024-03-31 00:00:00+00:00  +      -1.0  SPX\n</code></pre>"},{"location":"specifications/timetable/#track","title":"Track","text":"<p>A string identifier for the contract, a leg of the contract, or a state of the contract. For simple contracts this might be just blank. See more in Tracks.</p>"},{"location":"specifications/timetable/#time","title":"Time","text":"<p>The UNIX timestamp (milliseconds) of an event.</p>"},{"location":"specifications/timetable/#op","title":"Op","text":"<p>A string which can be <code>+</code>, <code>&gt;</code>, <code>&lt;</code>, or a condition. See more in Operations.</p>"},{"location":"specifications/timetable/#quantity","title":"Quantity","text":"<p>The quantity being paid (float).</p>"},{"location":"specifications/timetable/#unit","title":"Unit","text":"<p>A string that represents what is being paid. It can be a currency like <code>USD</code>, <code>EUR</code>, or a stock like <code>SPX</code>, <code>AAPL</code>, etc. See the Units section for all possible variants.</p>"},{"location":"specifications/timetable/#how-to-create-a-timetable","title":"How to create a timetable","text":"<p>The timetable is a dictionary with two components.</p> <ul> <li>events: the sequence of events stored as a pyarrow recordbatch</li> <li>expressions: a dictionary defining any phrases, snappers, or batches used in the timetable</li> </ul> <p>A timetable can be created as follows, from a list of dicts. In this example we define a contract that pays 100 USD on 2024-12-31.</p> <pre><code>import pyarrow as pa\nimport datetime\nfrom qablet_contracts.timetable import TS_EVENT_SCHEMA\n\nevents = [\n    {\n        \"track\": \"\",\n        \"time\": datetime(2024, 12, 31),\n        \"op\": \"+\",\n        \"quantity\": 100.0,\n        \"unit\": \"USD\",\n    },\n]\ntimetable = {\n    \"events\": pa.RecordBatch.from_pylist(events, schema=TS_EVENT_SCHEMA),\n    \"expressions\": {},\n}\n</code></pre>"},{"location":"specifications/timetable/#create-a-timetable-using-eventsmixin","title":"Create a Timetable using <code>EventsMixin</code>","text":"<p>Alternatively, the same timetable as above can also be created using the <code>EventsMixin</code> class as shown below.</p> <pre><code>from qablet_contracts.timetable import EventsMixin\n\n@dataclass\nclass Bond(EventsMixin):\n    ccy: str\n    maturity: datetime\n    track: str = \"\"\n\n    def events(self):\n        return [\n            {\n                \"track\": self.track,\n                \"time\": self.maturity,\n                \"op\": \"+\",\n                \"quantity\": 1,\n                \"unit\": self.ccy,\n            }\n        ]\n\ntimetable = Bond(\"USD\", datetime(2024, 12, 31)).timetable()\nprint(\"zcb:\\n\", timetable[\"events\"].to_pandas())\n</code></pre>"},{"location":"specifications/timetable/#qablet_contractstimetable","title":"<code>qablet_contracts.timetable</code>","text":"<p>This module has several utilities to help create timetables.</p>"},{"location":"specifications/timetable/#qablet_contracts.timetable.EventsMixin","title":"<code>EventsMixin</code>","text":"<p>             Bases: <code>ABC</code></p> <p>A mixin class for contracts that generates a timetable from events list. A derived class needs to implement the events method that returns a list of dicts, and the expressions method (optional) that returns a dictionary of expressions, batches, and snappers.</p> Source code in <code>qablet_contracts\\timetable.py</code> <pre><code>class EventsMixin(ABC):\n    \"\"\"A mixin class for contracts that generates a timetable from events list.\n    A derived class needs to implement the events method that returns a list of dicts,\n    and the expressions method (optional) that returns a dictionary of expressions, batches, and snappers.\"\"\"\n\n    @abstractmethod\n    def events(self) -&gt; List[Dict]: ...\n\n    def expressions(self) -&gt; Dict:\n        return {}\n\n    def timetable(self):\n        return {\n            \"events\": pa.RecordBatch.from_pylist(\n                self.events(), schema=TS_EVENT_SCHEMA\n            ),\n            \"expressions\": self.expressions(),\n        }\n</code></pre>"},{"location":"specifications/timetable/#qablet_contracts.timetable.timetable_from_dicts","title":"<code>timetable_from_dicts(events)</code>","text":"<p>Create timetable from a list of dicts. This method creates a timetable with floating point for time, which is now being deprecated.</p> <p>Parameters:</p> Name Type Description Default <code>events</code> <code>List[Dict]</code> <p>a list of dicts with the following fields:</p> <ul> <li>track: string</li> <li>time: float</li> <li>op: string</li> <li>quantity: float</li> <li>unit: string</li> </ul> required <p>Returns:</p> Type Description <code>Dict</code> <p>a timetable dictionary with the following fields:</p> <ul> <li>events: a pyarrow record batch</li> <li>expressions: a dict for expressions, batches, and snappers</li> </ul> Source code in <code>qablet_contracts\\timetable.py</code> <pre><code>def timetable_from_dicts(events: List[Dict]) -&gt; Dict:\n    \"\"\"Create timetable from a list of dicts. This method creates a timetable\n    with floating point for time, which is now being deprecated.\n\n    Args:\n        events: a list of dicts with the following fields:\n\n            - track: string\n            - time: float\n            - op: string\n            - quantity: float\n            - unit: string\n\n    Returns:\n        a timetable dictionary with the following fields:\n\n            - events: a pyarrow record batch\n            - expressions: a dict for expressions, batches, and snappers\n\n    \"\"\"\n    return {\n        \"events\": pa.RecordBatch.from_pylist(events, schema=EVENT_SCHEMA),\n        \"expressions\": {},\n    }\n</code></pre>"},{"location":"specifications/timetable/#qablet_contracts.timetable.py_to_ts","title":"<code>py_to_ts(py_dt)</code>","text":"<p>Convert a python datetime to a pyarrow timestamp (milliseconds).</p> Source code in <code>qablet_contracts\\timetable.py</code> <pre><code>def py_to_ts(py_dt):\n    \"\"\"Convert a python datetime to a pyarrow timestamp (milliseconds).\"\"\"\n    return pa.scalar(py_dt, type=TS_TYPE)\n</code></pre>"},{"location":"specifications/timetable/#qablet_contracts.timetable.convert_time_to_ts","title":"<code>convert_time_to_ts(timetable, base_ts)</code>","text":"<p>Convert events of timetable in place, changing time column into timestamp column. This function is used convert timetables created by legacy methods that use floating point for time into timetables with timestamp for time.</p> Source code in <code>qablet_contracts\\timetable.py</code> <pre><code>def convert_time_to_ts(timetable, base_ts):\n    \"\"\"Convert events of timetable in place, changing time column into timestamp column.\n    This function is used convert timetables created by legacy methods that use floating point\n    for time into timetables with timestamp for time.\"\"\"\n    events = timetable[\"events\"]\n\n    if events[\"time\"].type == pa.float64():\n        ts_list = [\n            base_ts + t.as_py() * 31_536_000_000 for t in events[\"time\"]\n        ]\n\n        timetable[\"events\"] = pa.RecordBatch.from_arrays(\n            [\n                events[\"track\"],\n                ts_list,\n                events[\"op\"],\n                events[\"quantity\"],\n                events[\"unit\"],\n            ],\n            schema=TS_EVENT_SCHEMA,\n        )\n</code></pre>"},{"location":"specifications/tracks/","title":"Tracks","text":"<p>A track identifies the contract, a leg of the contract, or a state of the contract. For simple contracts this might be just blank.</p> <pre><code>&gt;&gt;&gt; timetable = Option(\n    \"USD\", \"SPX\", 2900, datetime(2024, 3, 31), True\n).timetable()\n&gt;&gt;&gt; print(timetable[\"events\"].to_pandas())\n\n  track                      time op  quantity unit\n0       2024-03-31 00:00:00+00:00  &gt;       0.0  USD\n1       2024-03-31 00:00:00+00:00  +   -2900.0  USD\n2       2024-03-31 00:00:00+00:00  +       1.0  SPX\n</code></pre> <p>Or you could assign a name to the track.</p> <pre><code>&gt;&gt;&gt; timetable = Option(\n    \"USD\", \"SPX\", 2900, datetime(2024, 3, 31), True, \"&lt;SPX2900&gt;\"\n).timetable()\n&gt;&gt;&gt; print(timetable[\"events\"].to_pandas())\n\n       track                      time op  quantity unit\n0  &lt;SPX2900&gt; 2024-03-31 00:00:00+00:00  &gt;       0.0  USD\n1  &lt;SPX2900&gt; 2024-03-31 00:00:00+00:00  +   -2900.0  USD\n2  &lt;SPX2900&gt; 2024-03-31 00:00:00+00:00  +       1.0  SPX\n</code></pre> <p>In this example there are two tracks - <code>.opt</code> and <code>.swp</code>. In the event <code>0</code> and <code>3</code> the holder has an opportunity to switch from the <code>.opt</code> track (which has no payments) to the <code>.swp</code> track (which has payments). See Bermuda Swaption for more on this example.</p> <pre><code>  track                      time op  quantity  unit\n0  .opt 2023-12-31 00:00:00+00:00  &gt;     1.000  .swp\n1  .swp 2023-12-31 00:00:00+00:00  +     1.000   USD\n2  .swp 2024-06-30 00:00:00+00:00  +    -1.015   USD\n3  .opt 2024-06-30 00:00:00+00:00  &gt;     1.000  .swp\n4  .swp 2024-06-30 00:00:00+00:00  +     1.000   USD\n5  .swp 2024-12-31 00:00:00+00:00  +    -1.015   USD\n</code></pre>"},{"location":"specifications/units/","title":"Unit","text":"<p>A string representing what is being paid. It can be a </p> <ul> <li>a currency like <code>USD</code>, <code>EUR</code>. e.g. see Bonds</li> <li>a stock, or a commodity, like <code>AAPL</code>, <code>CL</code>. e.g. see Vanilla Option</li> <li>a Track, e.g. the fixed leg of a swap. e.g. see Bermuda Swaption</li> <li>a Phrase, e.g. a libor fixing, or a digital payoff. e.g. see Autocallable Note</li> <li>a Batch event, e.g. issuers option to deliver one of many bonds. See more in the Batch section.</li> <li>a Snap, i.e. a path dependent quantity, e.g. an accumulator cliquet. See more in the Snapper section.</li> </ul> <p>It can also represent an action, such as</p> <ul> <li>a Snapper, e.g update an accumulator from the current return.</li> </ul>"}]}